<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Nginx安装</title>
      <link href="2020/11/2020-11-23%20Nginx%E5%AE%89%E8%A3%85/"/>
      <url>2020/11/2020-11-23%20Nginx%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p><img src="" alt="https://upload-images.jianshu.io/upload_images/12902848-06d0fe297057ff05?imageMogr2/auto-orient/strip|imageView2/2/w/589/format/webp"></p><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><p><a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a><br> 下载：<a href="http://nginx.org/download/" target="_blank" rel="noopener">http://nginx.org/download/</a></p><h3 id="Nginx版本类型"><a href="#Nginx版本类型" class="headerlink" title="Nginx版本类型"></a>Nginx版本类型</h3><p>Nginx官网提供了三个类型的版本<br> Mainline version：Mainline是Nginx目前主力在做的版本,开发版<br> Stable version：最新稳定版,生产环境上建议使用的版本<br> Legacy versions：遗留的老的稳定版<br> 我们安装的时候注意在官网选择安装Stable的版本<br> 这里我们选择的是nginx-1.12.2</p><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CentOS 6.5 x64</span><br><span class="line"><span class="meta">#</span><span class="bash">设置hostname</span></span><br><span class="line">master 192.168.40.130</span><br></pre></td></tr></table></figure><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>源码编译安装</p><h3 id="安装依赖类库"><a href="#安装依赖类库" class="headerlink" title="安装依赖类库"></a>安装依赖类库</h3><p>c++  nginx的编译依赖<br> prce  重定向支持<br> openssl https支持</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> yum install gcc-c++</span></span><br><span class="line"><span class="meta">]#</span><span class="bash"> yum -y install pcre*</span></span><br><span class="line"><span class="meta">]#</span><span class="bash"> yum -y install openssl*</span></span><br></pre></td></tr></table></figure><h3 id="查看依赖类库安装情况"><a href="#查看依赖类库安装情况" class="headerlink" title="查看依赖类库安装情况"></a>查看依赖类库安装情况</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> rpm -qa  gcc-c++</span></span><br><span class="line">gcc-c++-4.4.7-18.el6_9.2.x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">]#</span><span class="bash"> rpm -qa  pcre*</span></span><br><span class="line">pcre-static-7.8-7.el6.x86_64</span><br><span class="line">pcre-7.8-7.el6.x86_64</span><br><span class="line">pcre-devel-7.8-7.el6.x86_64</span><br><span class="line"></span><br><span class="line"><span class="meta">]#</span><span class="bash"> rpm -qa  openssl*</span></span><br><span class="line">openssl098e-0.9.8e-20.el6.centos.1.x86_64</span><br><span class="line">openssl-perl-1.0.1e-57.el6.x86_64</span><br><span class="line">openssl-1.0.1e-57.el6.x86_64</span><br><span class="line">openssl-devel-1.0.1e-57.el6.x86_64</span><br><span class="line">openssl-static-1.0.1e-57.el6.x86_64</span><br></pre></td></tr></table></figure><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> wget http://nginx.org/download/nginx-1.12.2.tar.gz</span></span><br><span class="line"><span class="meta">]#</span><span class="bash"> tar -xzvf nginx-1.12.2.tar.gz </span></span><br><span class="line"><span class="meta">]#</span><span class="bash"> <span class="built_in">cd</span> nginx-1.12.2</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置安装目录为 /usr/<span class="built_in">local</span>/src/nginx </span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置支持https</span></span><br><span class="line"><span class="meta">]#</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span>/src/nginx --with-http_ssl_module</span></span><br></pre></td></tr></table></figure><h5 id="configure"><a href="#configure" class="headerlink" title="./configure"></a>./configure</h5><p>执行<code>./configure ***</code> 命令后终端上会有些输出<br> 输出的信息里会包含依赖的组件是否完整，如果不完整则需要另行安装<br> 输出的信息里会包含配置文件目录信息，日志文件目录信息等一些很重要的我们做运维依赖的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Configuration summary</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + using system OpenSSL library</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: "/usr/local/src/nginx"</span><br><span class="line">  nginx binary file: "/usr/local/src/nginx/sbin/nginx"</span><br><span class="line">  nginx modules path: "/usr/local/src/nginx/modules"</span><br><span class="line">  nginx configuration prefix: "/usr/local/src/nginx/conf"</span><br><span class="line">  nginx configuration file: "/usr/local/src/nginx/conf/nginx.conf"</span><br><span class="line">  nginx pid file: "/usr/local/src/nginx/logs/nginx.pid"</span><br><span class="line">  nginx error log file: "/usr/local/src/nginx/logs/error.log"</span><br><span class="line">  nginx http access log file: "/usr/local/src/nginx/logs/access.log"</span><br><span class="line">  nginx http client request body temporary files: "client_body_temp"</span><br><span class="line">  nginx http proxy temporary files: "proxy_temp"</span><br><span class="line">  nginx http fastcgi temporary files: "fastcgi_temp"</span><br><span class="line">  nginx http uwsgi temporary files: "uwsgi_temp"</span><br><span class="line">  nginx http scgi temporary files: "scgi_temp"</span><br></pre></td></tr></table></figure><h5 id="make"><a href="#make" class="headerlink" title="make"></a>make</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">#</span><span class="bash">省略若干行</span></span><br><span class="line">sed -e "s|%%PREFIX%%|/usr/local/src/nginx|" \</span><br><span class="line">        -e "s|%%PID_PATH%%|/usr/local/src/nginx/logs/nginx.pid|" \</span><br><span class="line">        -e "s|%%CONF_PATH%%|/usr/local/src/nginx/conf/nginx.conf|" \</span><br><span class="line">        -e "s|%%ERROR_LOG_PATH%%|/usr/local/src/nginx/logs/error.log|" \</span><br><span class="line">        &lt; man/nginx.8 &gt; objs/nginx.8</span><br><span class="line">make[1]: Leaving directory `/soft/nginx-1.12.2'</span><br></pre></td></tr></table></figure><h5 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> vim /etc/profile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> nginx environment</span></span><br><span class="line">export NGINX_HOME=/usr/local/src/nginx</span><br><span class="line">export PATH=$&#123;NGINX_HOME&#125;/sbin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">]#</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><h5 id="nginx-命令行"><a href="#nginx-命令行" class="headerlink" title="nginx 命令行"></a>nginx 命令行</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> nginx -h</span></span><br><span class="line">nginx version: nginx/1.12.2</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /usr/local/src/nginx/)</span><br><span class="line">  -c filename   : set configuration file (default: conf/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></table></figure><ul><li>启动 nginx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> nginx</span></span><br><span class="line"><span class="meta">]#</span><span class="bash"> nginx -s reload</span></span><br><span class="line"><span class="meta">]#</span><span class="bash"> nginx -s stop</span></span><br></pre></td></tr></table></figure><ul><li>重启 nginx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> nginx -s reload</span></span><br></pre></td></tr></table></figure><ul><li>关闭 nginx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> nginx -s stop</span></span><br></pre></td></tr></table></figure><p>或者 查进程号之后 <code>kill -9 pid</code></p><h5 id="nginx-安装验证"><a href="#nginx-安装验证" class="headerlink" title="nginx 安装验证"></a>nginx 安装验证</h5><ul><li>验证nginx进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">]#</span><span class="bash"> ps -ef | grep nginx</span></span><br><span class="line">root      1253     1  0 10:54 ?        00:00:00 nginx: master process ./nginx</span><br><span class="line">nobody    1254  1253  0 10:54 ?        00:00:00 nginx: worker process</span><br><span class="line">root      1267 56707  0 10:54 pts/4    00:00:00 grep nginx</span><br></pre></td></tr></table></figure><p>可以看到nginx的master和worker进程</p><ul><li>验证nginx默认页面</li></ul><p>启动nginx后可以通过主机名或者ip进行访问验证<br> <a href="http://master/" target="_blank" rel="noopener">http://master/</a><br> <a href="http://192.168.40.130/" target="_blank" rel="noopener">http://192.168.40.130/</a></p><p><img src="https:////upload-images.jianshu.io/upload_images/12902848-2f1a9eced9827a7a?imageMogr2/auto-orient/strip%7CimageView2/2/w/526/format/webp" alt="img"></p><p> 看到以上页面则证明nginx安装成功</p><p>作者：寒后惊雷<br>链接：<a href="https://www.jianshu.com/p/ccb58fb68455" target="_blank" rel="noopener">https://www.jianshu.com/p/ccb58fb68455</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google浏览器对于部分端口访问限制</title>
      <link href="2020/11/2020-11-17%20Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E4%BA%8E%E9%83%A8%E5%88%86%E7%AB%AF%E5%8F%A3%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/"/>
      <url>2020/11/2020-11-17%20Google%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E4%BA%8E%E9%83%A8%E5%88%86%E7%AB%AF%E5%8F%A3%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>谷歌浏览器限制的一些端口号：<br>1： // tcpmux<br>7： // echo<br>9： // discard<br>11： // systat<br>13： // daytime<br>15： // netstat<br>17： // qotd<br>19： // chargen<br>20： // ftp data<br>21： // ftp access<br>22： // ssh<br>23： // telnet<br>25： // smtp<br>37： // time<br>42： // name<br>43： // nicname<br>53： // domain<br>77： // priv-rjs<br>79： // finger<br>87： // ttylink<br>95： // supdup<br>101： // hostriame<br>102： // iso-tsap<br>103： // gppitnp<br>104： // acr-nema<br>109： // pop2<br>110： // pop3<br>111： // sunrpc<br>113： // auth<br>115： // sftp<br>117： // uucp-path<br>119： // nntp<br>123： // NTP<br>135： // loc-srv /epmap<br>139： // netbios<br>143： // imap2<br>179： // BGP<br>389： // ldap<br>465： // smtp+ssl<br>512： // print / exec<br>513： // login<br>514： // shell<br>515： // printer<br>526： // tempo<br>530： // courier<br>531： // chat<br>532： // netnews<br>540： // uucp<br>556： // remotefs<br>563： // nntp+ssl<br>587： // stmp?<br>601： // ??<br>636： // ldap+ssl<br>993： // ldap+ssl<br>995： // pop3+ssl<br>2049： // nfs<br>3659： // apple-sasl / PasswordServer<br>4045： // lockd<br>6000： // X11<br>6665： // Alternate IRC [Apple addition]<br>6666： // Alternate IRC [Apple addition]<br>6667： // Standard IRC [Apple addition]<br>6668： // Alternate IRC [Apple addition]<br>6669： // Alternate IRC [Apple addition]</p>]]></content>
      
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码(二)之AOP</title>
      <link href="2020/10/2020-10-27-Spring%E6%BA%90%E7%A0%81(%E4%BA%8C)%E4%B9%8BAOP/"/>
      <url>2020/10/2020-10-27-Spring%E6%BA%90%E7%A0%81(%E4%BA%8C)%E4%B9%8BAOP/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码(一)之容器创建</title>
      <link href="2020/10/2020-10-27-Spring%E6%BA%90%E7%A0%81(%E4%B8%89)%E4%B9%8BIOC/"/>
      <url>2020/10/2020-10-27-Spring%E6%BA%90%E7%A0%81(%E4%B8%89)%E4%B9%8BIOC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码(一)之容器创建</title>
      <link href="2020/10/2020-10-27-Spring%E6%BA%90%E7%A0%81(%E4%B8%80)%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA/"/>
      <url>2020/10/2020-10-27-Spring%E6%BA%90%E7%A0%81(%E4%B8%80)%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种分布式锁的对比与实现</title>
      <link href="2020/10/2020-10-12-%E4%B8%89%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/10/2020-10-12-%E4%B8%89%E7%A7%8D%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>转载于 <a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1716</a> </p><p>目前几乎很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。</p><p>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案。</p><p>针对分布式锁的实现，目前比较常用的有以下几种方案：</p><blockquote><p>基于数据库实现分布式锁 基于缓存（redis，memcached，tair）实现分布式锁 基于Zookeeper实现分布式锁</p></blockquote><p>在分析这几种实现方案之前我们先来想一下，我们需要的分布式锁应该是怎么样的？（这里以方法锁为例，资源锁同理）</p><blockquote><p>可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。</p><p>这把锁要是一把可重入锁（避免死锁）</p><p>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）</p><p>有高可用的获取锁和释放锁功能</p><p>获取锁和释放锁的性能要好</p></blockquote><hr><h3 id="基于数据库实现分布式锁"><a href="#基于数据库实现分布式锁" class="headerlink" title="基于数据库实现分布式锁"></a>基于数据库实现分布式锁</h3><h4 id="基于数据库表"><a href="#基于数据库表" class="headerlink" title="基于数据库表"></a>基于数据库表</h4><p>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。</p><p>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</p><p>创建这样一张数据库表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;methodLock&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;method_name&#96; varchar(64) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;锁定的方法名&#39;,</span><br><span class="line">  &#96;desc&#96; varchar(1024) NOT NULL DEFAULT &#39;备注信息&#39;,</span><br><span class="line">  &#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &#39;保存数据时间，自动生成&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;),</span><br><span class="line">  UNIQUE KEY &#96;uidx_method_name&#96; (&#96;method_name &#96;) USING BTREE</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;锁定中的方法&#39;;</span><br></pre></td></tr></table></figure><p>当我们想要锁住某个方法时，执行以下SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into methodLock(method_name,desc) values (‘method_name’,‘desc’)</span><br></pre></td></tr></table></figure><p>因为我们对<code>method_name</code>做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p><p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from methodLock where method_name &#x3D;&#39;method_name&#39;</span><br></pre></td></tr></table></figure><p>上面这种简单的实现有以下几个问题：</p><blockquote><p>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</p><p>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</p><p>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</p><p>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p></blockquote><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li><li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li></ul><hr><h4 id="基于数据库排他锁"><a href="#基于数据库排他锁" class="headerlink" title="基于数据库排他锁"></a>基于数据库排他锁</h4><p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据中自带的锁来实现分布式的锁。</p><p>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。 基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.setAutoCommit(<span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            result = select * from methodLock where method_name=xxx <span class="keyword">for</span> update;</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在查询语句后面增加<code>for update</code>，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    connection.commit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>connection.commit()</code>操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。</p><p><strong>这里还可能存在另外一个问题，虽然我们对<code>method_name</code> 使用了唯一索引，并且显示使用<code>for update</code>来使用行级锁。但是，MySql会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。如果发生这种情况就悲剧了。。。</strong></p><hr><p><strong>还有一个问题，就是我们要使用排他锁来进行分布式锁的lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆</strong></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</p><p><strong>数据库实现分布式锁的优点</strong></p><p>直接借助数据库，容易理解。</p><p><strong>数据库实现分布式锁的缺点</strong></p><p>会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</p><p>操作数据库需要一定的开销，性能问题需要考虑。</p><p>使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p><hr><h3 id="基于缓存实现分布式锁"><a href="#基于缓存实现分布式锁" class="headerlink" title="基于缓存实现分布式锁"></a>基于缓存实现分布式锁</h3><p>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</p><p>目前有很多成熟的缓存产品，包括Redis，memcached以及我们公司内部的Tair。</p><p>这里以Tair为例来分析下使用缓存实现分布式锁的方案。关于Redis和memcached在网络上有很多相关的文章，并且也有一些成熟的框架及算法可以直接使用。</p><p>基于Tair的实现分布式锁其实和Redis类似，其中主要的实现方式是使用<code>TairManager.put</code>方法来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trylock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    ResultCode code = ldbTairManager.put(NAMESPACE, key, <span class="string">"This is a Lock."</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ResultCode.SUCCESS.equals(code))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    ldbTairManager.invalid(NAMESPACE, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现方式同样存在几个问题：</p><blockquote><p>1、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在tair中，其他线程无法再获得到锁。</p><p>2、这把锁只能是非阻塞的，无论成功还是失败都直接返回。</p><p>3、这把锁是非重入的，一个线程获得锁之后，在释放锁之前，无法再次获得该锁，因为使用到的key在tair中已经存在。无法再执行put操作。</p></blockquote><p>当然，同样有方式可以解决。</p><ul><li>没有失效时间？tair的put方法支持传入失效时间，到达时间之后数据会自动删除。</li><li>非阻塞？while重复执行。</li><li>非可重入？在一个线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取之前先检查自己是不是当前锁的拥有者。</li></ul><p><strong>但是，失效时间我设置多长时间为好？如何设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。如果设置的时间太长，其他获取锁的线程就可能要平白的多等一段时间。</strong>这个问题使用数据库实现分布式锁同样存在</p><hr><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如Tair的put方法，redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。</p><p><strong>使用缓存实现分布式锁的优点</strong></p><p>性能好，实现起来较为方便。</p><p><strong>使用缓存实现分布式锁的缺点</strong></p><p>通过超时时间来控制锁的失效时间并不是十分的靠谱。</p><hr><h3 id="基于Zookeeper实现分布式锁"><a href="#基于Zookeeper实现分布式锁" class="headerlink" title="基于Zookeeper实现分布式锁"></a>基于Zookeeper实现分布式锁</h3><p>基于zookeeper临时有序节点可以实现的分布式锁。</p><p>大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p><p>来看下Zookeeper能不能解决前面提到的问题。</p><ul><li>锁无法释放？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li><li>非阻塞锁？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li><li>不可重入？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li><li>单点问题？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li></ul><p>可以直接使用zookeeper第三方库<a href="https://curator.apache.org/" target="_blank" rel="noopener">Curator</a>客户端，这个客户端中封装了一个可重入的锁服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> interProcessMutex.acquire(timeout, unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        interProcessMutex.release();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.schedule(<span class="keyword">new</span> Cleaner(client, path), delayTimeForClean, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Curator提供的InterProcessMutex是分布式锁的实现。acquire方法用户获取锁，release方法用于释放锁。</p><p>使用ZK实现的分布式锁好像完全符合了本文开头我们对一个分布式锁的所有期望。但是，其实并不是，Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。</p><p><strong>其实，使用Zookeeper也有可能带来并发问题，只是并不常见而已。考虑这样的情况，由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，Curator客户端支持多种重试策略。多次重试之后还不行的话才会删除临时节点。（所以，选择一个合适的重试策略也比较重要，要在锁的粒度和并发之间找一个平衡。）</strong></p><hr><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p><strong>使用Zookeeper实现分布式锁的优点</strong></p><p>有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p><p><strong>使用Zookeeper实现分布式锁的缺点</strong></p><p>性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p><hr><h3 id="三种方案的比较"><a href="#三种方案的比较" class="headerlink" title="三种方案的比较"></a>三种方案的比较</h3><p>上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。</p><h4 id="从理解的难易程度角度（从低到高）"><a href="#从理解的难易程度角度（从低到高）" class="headerlink" title="从理解的难易程度角度（从低到高）"></a>从理解的难易程度角度（从低到高）</h4><p>数据库 &gt; 缓存 &gt; Zookeeper</p><h4 id="从实现的复杂性角度（从低到高）"><a href="#从实现的复杂性角度（从低到高）" class="headerlink" title="从实现的复杂性角度（从低到高）"></a>从实现的复杂性角度（从低到高）</h4><p>Zookeeper &gt;= 缓存 &gt; 数据库</p><h4 id="从性能角度（从高到低）"><a href="#从性能角度（从高到低）" class="headerlink" title="从性能角度（从高到低）"></a>从性能角度（从高到低）</h4><p>缓存 &gt; Zookeeper &gt;= 数据库</p><h4 id="从可靠性角度（从高到低）"><a href="#从可靠性角度（从高到低）" class="headerlink" title="从可靠性角度（从高到低）"></a>从可靠性角度（从高到低）</h4><p>Zookeeper &gt; 缓存 &gt; 数据库</p><p>扩展参考：<a href="https://my.oschina.net/yangjianzhou/blog/1930493" target="_blank" rel="noopener">https://my.oschina.net/yangjianzhou/blog/1930493</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> redis </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yarn的使用</title>
      <link href="2020/10/2020-10-11-yarn%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2020/10/2020-10-11-yarn%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://yarn.bootcss.com" target="_blank" rel="noopener">官方网站</a></p><h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><h3 id="1-1-Windows下"><a href="#1-1-Windows下" class="headerlink" title="1.1 Windows下"></a>1.1 Windows下</h3><h4 id="1-1-1-通过NPM安装"><a href="#1-1-1-通过NPM安装" class="headerlink" title="1.1.1 通过NPM安装"></a>1.1.1 通过NPM安装</h4><p>保证已安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br><span class="line"><span class="meta">#</span><span class="bash">或</span></span><br><span class="line">npm install -g yarn --registry=https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置yarn源【可选】</span></span><br><span class="line">yarn config set registry https://registry.npm.taobao.org -g</span><br><span class="line">yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g</span><br></pre></td></tr></table></figure><p><code>npm与yarn比较</code></p><table><thead><tr><th align="left">npm</th><th align="left">Yarn</th></tr></thead><tbody><tr><td align="left"><code>npm install</code></td><td align="left"><code>yarn install</code></td></tr><tr><td align="left"><strong>(N/A)</strong></td><td align="left"><code>yarn install --flat</code></td></tr><tr><td align="left"><strong>(N/A)</strong></td><td align="left"><code>yarn install --har</code></td></tr><tr><td align="left"><strong>(N/A)</strong></td><td align="left"><code>yarn install --no-lockfile</code></td></tr><tr><td align="left"><strong>(N/A)</strong></td><td align="left"><code>yarn install --pure-lockfile</code></td></tr><tr><td align="left"><code>npm install [package]</code></td><td align="left"><strong>(N/A)</strong></td></tr><tr><td align="left"><code>npm install --save [package]</code></td><td align="left"><code>yarn add [package]</code></td></tr><tr><td align="left"><code>npm install --save-dev [package]</code></td><td align="left"><code>yarn add [package] [--dev/-D]</code></td></tr><tr><td align="left"><strong>(N/A)</strong></td><td align="left"><code>yarn add [package] [--peer/-P]</code></td></tr><tr><td align="left"><code>npm install --save-optional [package]</code></td><td align="left"><code>yarn add [package] [--optional/-O]</code></td></tr><tr><td align="left"><code>npm install --save-exact [package]</code></td><td align="left"><code>yarn add [package] [--exact/-E]</code></td></tr><tr><td align="left"><strong>(N/A)</strong></td><td align="left"><code>yarn add [package] [--tilde/-T]</code></td></tr><tr><td align="left"><code>npm install --global [package]</code></td><td align="left"><code>yarn global add [package]</code></td></tr><tr><td align="left"><code>npm rebuild</code></td><td align="left"><code>yarn install --force</code></td></tr><tr><td align="left"><code>npm uninstall [package]</code></td><td align="left"><strong>(N/A)</strong></td></tr><tr><td align="left"><code>npm uninstall --save [package]</code></td><td align="left"><code>yarn remove [package]</code></td></tr><tr><td align="left"><code>npm uninstall --save-dev [package]</code></td><td align="left"><code>yarn remove [package]</code></td></tr><tr><td align="left"><code>npm uninstall --save-optional [package]</code></td><td align="left"><code>yarn remove [package]</code></td></tr><tr><td align="left"><code>npm cache clean</code></td><td align="left"><code>yarn cache clean</code></td></tr><tr><td align="left"><code>rm -rf node_modules &amp;&amp; npm install</code></td><td align="left"><code>yarn upgrade</code></td></tr></tbody></table><h4 id="1-1-2-其他方式参考官网"><a href="#1-1-2-其他方式参考官网" class="headerlink" title="1.1.2 其他方式参考官网"></a>1.1.2 其他方式参考官网</h4><h4 id="1-1-3-注意"><a href="#1-1-3-注意" class="headerlink" title="1.1.3 注意"></a>1.1.3 注意</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">测试安装是否成功</span></span><br><span class="line">yarn --version</span><br></pre></td></tr></table></figure><h3 id="1-2-CentOS下"><a href="#1-2-CentOS下" class="headerlink" title="1.2 CentOS下"></a>1.2 CentOS下</h3><blockquote><p>其他Linux发行版参见<a href="https://yarn.bootcss.com/docs/install/#debian-stable" target="_blank" rel="noopener">这里</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置RPM库</span></span><br><span class="line">curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置Node源库</span></span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</span><br><span class="line"></span><br><span class="line">sudo yum install yarn</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># OR ##</span></span></span><br><span class="line">sudo dnf install yarn</span><br></pre></td></tr></table></figure><h4 id="1-2-1-Path-Setup"><a href="#1-2-1-Path-Setup" class="headerlink" title="1.2.1 Path Setup"></a>1.2.1 Path Setup</h4><p>​    如果未在 PATH 环境变量中找到 yarn，请按照以下步骤添加 yarn 到 PATH 环境变量中，使其可以随处运行。</p><p>注意：您的配置文件可能是 <code>.profile</code>、<code>.bash_profile</code>、<code>.bashrc</code>、<code>.zshrc</code> 等。</p><ul><li><p>将此项加入您的配置文件： <code>export PATH=&quot;$PATH:/opt/yarn-[version]/bin&quot;</code> （路径可能根据您安装 Yarn 的位置而有差异）</p></li><li><p>在终端中，执行登录并登出以使更改生效</p></li></ul><p>为了可以全局访问 Yarn 的可执行文件，你需要在控制台（或命令行）中设置 <code>PATH</code> 环境变量。若要执行此操作，请添加 <code>export PATH=&quot;$PATH:</code>yarn global bin<code>&quot;</code> 到你的配置文件中，或者，如果你使用的是 Fish shell，直接执行此命令 <code>set -U fish_user_paths (yarn global bin) $fish_user_paths</code> 即可。</p><h4 id="1-2-3-注意"><a href="#1-2-3-注意" class="headerlink" title="1.2.3 注意"></a>1.2.3 注意</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn --version</span><br></pre></td></tr></table></figure><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化一个新项目</span></span><br><span class="line">yarn init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加依赖包</span></span><br><span class="line">yarn add [package]</span><br><span class="line">yarn add [package]@[version]</span><br><span class="line">yarn add [package]@[tag]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将依赖项添加到不同依赖项类别中</span></span><br><span class="line">yarn add [package] --dev</span><br><span class="line">yarn add [package] --peer</span><br><span class="line">yarn add [package] --optional</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级依赖包</span></span><br><span class="line">yarn upgrade [package]</span><br><span class="line">yarn upgrade [package]@[version]</span><br><span class="line">yarn upgrade [package]@[tag]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除依赖包</span></span><br><span class="line">yarn remove [package]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装项目的全部依赖</span></span><br><span class="line">yarn</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># OR ##</span></span></span><br><span class="line">yarn install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo的搜索实现之 hexo-generator-search</title>
      <link href="2020/10/2020-10-08-Hexo%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E4%B9%8B-hexo-generator-search/"/>
      <url>2020/10/2020-10-08-Hexo%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E4%B9%8B-hexo-generator-search/</url>
      
        <content type="html"><![CDATA[<p>转载于<a href="https://www.hahack.com/codes/local-search-engine-for-hexo/" target="_blank" rel="noopener">https://www.hahack.com/codes/local-search-engine-for-hexo/</a></p><h2 id="1-安装和配置-hexo-generator-search"><a href="#1-安装和配置-hexo-generator-search" class="headerlink" title="1. 安装和配置 hexo-generator-search"></a>1. 安装和配置 hexo-generator-search</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install --save hexo-generator-search</span></span><br></pre></td></tr></table></figure><p>然后，在站点根 <code>_config.yml</code> 里头添加设置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>path</strong> - 指定生成的索引数据的文件名。默认为 search.xml 。</li><li>field - 指定索引数据的生成范围。可选值包括：<ul><li><strong>post</strong> - 只生成博客文章（post）的索引（默认）；</li><li><strong>page</strong> - 只生成其他页面（page）的索引；</li><li><strong>all</strong> - 生成所有文章和页面的索引。</li></ul></li></ul><p>完成后，可以试试访问预览站点的 search.xml 页面。例如，如果你的预览站点域名是 <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000</a> ，那么可以访问 <a href="http://0.0.0.0:4000/search.xml" target="_blank" rel="noopener">http://0.0.0.0:4000/search.xml</a> 看看是否会打开一个 xml 页面。</p><h2 id="2-编写搜索界面"><a href="#2-编写搜索界面" class="headerlink" title="2. 编写搜索界面"></a>2. 编写搜索界面</h2><p>搜索界面由一个输入框（input）和一个用于动态插入搜索结果的 div 组成。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"site_search"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"local-search-input"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">results</span>=<span class="string">"0"</span> <span class="attr">placeholder</span>=<span class="string">"search my blog..."</span> <span class="attr">class</span>=<span class="string">"form-control"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search-result"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你也可以根据自己的喜好写成其他的形式，例如把用于插入结果的 div 移动到页面的其他地方。</p><h2 id="3-实现本地搜索函数"><a href="#3-实现本地搜索函数" class="headerlink" title="3. 实现本地搜索函数"></a>3. 实现本地搜索函数</h2><p>接下来编写一个 search.js 脚本，用来实现基于 search.xml 的本地检索函数 searchFunc ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">path, search_id, content_id</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: path,</span><br><span class="line">        dataType: <span class="string">"xml"</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"> xmlResponse </span>) </span>&#123;</span><br><span class="line">            <span class="comment">// get the contents from search data</span></span><br><span class="line">            <span class="keyword">var</span> datas = $( <span class="string">"entry"</span>, xmlResponse ).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    title: $( <span class="string">"title"</span>, <span class="keyword">this</span> ).text(),</span><br><span class="line">                    content: $(<span class="string">"content"</span>,<span class="keyword">this</span>).text(),</span><br><span class="line">                    url: $( <span class="string">"url"</span> , <span class="keyword">this</span>).text()</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> $input = <span class="built_in">document</span>.getElementById(search_id);</span><br><span class="line">            <span class="keyword">var</span> $resultContent = <span class="built_in">document</span>.getElementById(content_id);</span><br><span class="line"></span><br><span class="line">            $input.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> str=<span class="string">'&lt;ul class=\"search-result-list\"&gt;'</span>;                </span><br><span class="line">                <span class="keyword">var</span> keywords = <span class="keyword">this</span>.value.trim().toLowerCase().split(<span class="regexp">/[\s\-]+/</span>);</span><br><span class="line">                $resultContent.innerHTML = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.value.trim().length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// perform local searching</span></span><br><span class="line">                datas.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> isMatch = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">var</span> content_index = [];</span><br><span class="line">                    <span class="keyword">var</span> data_title = data.title.trim().toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>).toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_url = data.url;</span><br><span class="line">                    <span class="keyword">var</span> index_title = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> index_content = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> first_occur = <span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">// only match artiles with not empty titles and contents</span></span><br><span class="line">                    <span class="keyword">if</span>(data_title != <span class="string">''</span> &amp;&amp; data_content != <span class="string">''</span>) &#123;</span><br><span class="line">                        keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword, i</span>) </span>&#123;</span><br><span class="line">                            index_title = data_title.indexOf(keyword);</span><br><span class="line">                            index_content = data_content.indexOf(keyword);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>( index_title &lt; <span class="number">0</span> &amp;&amp; index_content &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                                isMatch = <span class="literal">false</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    index_content = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                                    first_occur = index_content;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// show search results</span></span><br><span class="line">                    <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">                        str += <span class="string">"&lt;li&gt;&lt;a href='"</span>+ data_url +<span class="string">"' class='search-result-title'&gt;"</span>+ data_title +<span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                        <span class="keyword">var</span> content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>);</span><br><span class="line">                        <span class="keyword">if</span> (first_occur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// cut out 100 characters</span></span><br><span class="line">                            <span class="keyword">var</span> start = first_occur - <span class="number">20</span>;</span><br><span class="line">                            <span class="keyword">var</span> end = first_occur + <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(start &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                                start = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</span><br><span class="line">                                end = <span class="number">100</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(end &gt; content.length)&#123;</span><br><span class="line">                                end = content.length;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">var</span> match_content = content.substr(start, end); </span><br><span class="line"></span><br><span class="line">                            <span class="comment">// highlight all keywords</span></span><br><span class="line">                            keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword</span>)</span>&#123;</span><br><span class="line">                                <span class="keyword">var</span> regS = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyword, <span class="string">"gi"</span>);</span><br><span class="line">                                match_content = match_content.replace(regS, <span class="string">"&lt;em class=\"search-keyword\"&gt;"</span>+keyword+<span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line">                            &#125;);</span><br><span class="line">                            </span><br><span class="line">                            str += <span class="string">"&lt;p class=\"search-result\"&gt;"</span> + match_content +<span class="string">"...&lt;/p&gt;"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        str += <span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                str += <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">                $resultContent.innerHTML = str;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>searchFunc 包含三个参数：</p><ul><li><strong>path</strong> - 用 hexo-generator-search 生成的搜索索引文件的路径。注意这个 <code>path</code> 和前面 hexo-generator-search 的 <code>path</code> 选项有所不同。这里的 path 才是指这个文件的路径，而前面的 <code>path</code> 指的是生成的文件名（也许第二个 <code>path</code> 叫 <code>filename</code> 更合适）；</li><li><strong>search_id</strong> - 搜索框的 id 。对于我们的例子，就是 <code>local-search-input</code>;</li><li><strong>content_id</strong> - 结果框的 id 。对于我们的例子，就是 <code>local-search-result</code>。</li></ul><h2 id="4-调用搜索函数"><a href="#4-调用搜索函数" class="headerlink" title="4. 调用搜索函数"></a>4. 调用搜索函数</h2><p>有了上面的检索函数，接下来可以在适当时机调用它。由于 path 的实际地址是根 <code>_config.yml</code> 里 <code>config.root</code> + <code>config.search.path</code> 两个值组成，所以我们最好将这个调用写在页面模板中，以方便获取站点的设置信息。例如，对于 ejs 模板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;      </span><br><span class="line">     <span class="keyword">var</span> search_path = <span class="string">"&lt;%= config.search.path %&gt;"</span>;</span><br><span class="line">     <span class="keyword">if</span> (search_path.length == <span class="number">0</span>) &#123;</span><br><span class="line">     search_path = <span class="string">"search.xml"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> path = <span class="string">"&lt;%= config.root %&gt;"</span> + search_path;</span><br><span class="line">     searchFunc(path, <span class="string">'local-search-input'</span>, <span class="string">'local-search-result'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>至此就完成了本地检索引擎的实线，最后的工作就是修改样式，让检索页面更美观。在 searchFunc 函数中，我已经为几个关键的页面元素设定了 css 名：</p><ul><li>ul.search-result-list - 搜索结果列表的样式名；</li><li>a.search-result-title - 搜索结果文章标题的样式名；</li><li>p.search-result - 搜索结果每篇文章的预览段落的样式名；</li><li>em.search-keyword - 搜索结果每篇文章的预览段落中匹配关键词的样式名。</li></ul><p>最后给出 <a href="http://wzpan.github.io/hexo-theme-freemind/" target="_blank" rel="noopener">hexo-theme-freemind</a> 主题的相关样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.search-result-list</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.search-result-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.search-result</span> &#123;</span><br><span class="line">  color=#555;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">em</span><span class="selector-class">.search-keyword</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#4088b8</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 关于本站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty</title>
      <link href="2020/05/java8/"/>
      <url>2020/05/java8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近有点烦有点烦...</title>
      <link href="2020/10/2020-10-04-%E5%A6%82%E4%BD%95%E4%BB%8E%E5%80%A6%E6%80%A0%E7%9A%84JVM%E4%B8%AD%E8%B7%B3%E5%87%BA%E6%9D%A5%E5%B9%B6%E6%8B%A5%E6%8A%B1%E4%B8%8A%E4%BA%86%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
      <url>2020/10/2020-10-04-%E5%A6%82%E4%BD%95%E4%BB%8E%E5%80%A6%E6%80%A0%E7%9A%84JVM%E4%B8%AD%E8%B7%B3%E5%87%BA%E6%9D%A5%E5%B9%B6%E6%8B%A5%E6%8A%B1%E4%B8%8A%E4%BA%86%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    说是引言，但其实已是全部。</p><p>​    照例来张图，”图文并茂”，欧耶！</p><p><img src="https://gitee.com/fagefocus/images/raw/mdPicture//xiaoxin_19.png" alt=""></p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java手册</title>
      <link href="2020/06/java-manual/"/>
      <url>2020/06/java-manual/</url>
      
        <content type="html"><![CDATA[<h1 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h1><h2 id="1-类封装与反射"><a href="#1-类封装与反射" class="headerlink" title="1.*类封装与反射"></a>1.*类封装与反射</h2><table><thead><tr><th>类封装</th><th>反射</th></tr></thead><tbody><tr><td>正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段</td><td>一种非常规的用法,会破坏对象的封装，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值</td></tr><tr><td></td><td><code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全</td></tr></tbody></table><p>除byte,char,short,int ,long,float.double.boolean这些基本数据类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>），如String，String[],Exception等。同时JVM为每一种基本类型，如int，也创建了<code>Class</code>，通过<code>int.class</code>访问(<em>其clazz.isPrimitive()的返回结果为true</em>)</p><h2 id="1-1-Class"><a href="#1-1-Class" class="headerlink" title="1.1 Class"></a>1.1 Class</h2><h3 id="1-1-1-如何获取一个class的Class实例？"><a href="#1-1-1-如何获取一个class的Class实例？" class="headerlink" title="1.1.1 如何获取一个class的Class实例？"></a>1.1.1 如何获取一个class的Class实例？</h3><table><thead><tr><th>1.通过一个<code>class</code>的静态变量<code>class</code>获取</th><th>Class cls = String.class;</th></tr></thead><tbody><tr><td>2.通过该实例变量提供的<code>getClass()</code>方法获取^前提:存在一个实例变量^</td><td>String s = “Hello”; Class cls = s.getClass();</td></tr><tr><td>3.通过静态方法<code>Class.forName()</code>获取^前提:知道一个<code>class</code>的完整类名^</td><td>Class cls = Class.forName(“java.lang.String”);</td></tr></tbody></table><p>三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型</p><h3 id="1-1-2-Class实例比较和instanceof的区别"><a href="#1-1-2-Class实例比较和instanceof的区别" class="headerlink" title="1.1.2 Class实例比较和instanceof的区别"></a>1.1.2 <code>Class</code>实例比较和<code>instanceof</code>的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true </span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th><code>instanceof</code></th><th><code>Class</code>实例比较</th></tr></thead><tbody><tr><td>区别</td><td>不但匹配指定类型，还匹配指定类型的子类</td><td>用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较</td></tr></tbody></table><p>​        <strong>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例</strong></p><h3 id="1-1-3-创建实例-newInstance"><a href="#1-1-3-创建实例-newInstance" class="headerlink" title="1.1.3 创建实例 newInstance()"></a>1.1.3 创建实例 <code>newInstance()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用。</span></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><h3 id="1-1-4-动态加载"><a href="#1-1-4-动态加载" class="headerlink" title="1.1.4 动态加载"></a>1.1.4 动态加载</h3><blockquote><p>VM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载</p><p>利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j,大致实现思路</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">"org.apache.logging.log4j.Logger"</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因</span></span><br></pre></td></tr></table></figure><h2 id="1-2-访问字段"><a href="#1-2-访问字段" class="headerlink" title="1.2 访问字段"></a>1.2 访问字段</h2><h3 id="1-2-1-通过Class实例获取字段信息"><a href="#1-2-1-通过Class实例获取字段信息" class="headerlink" title="1.2.1 通过Class实例获取字段信息"></a>1.2.1 通过<code>Class</code>实例获取字段信息</h3><table><thead><tr><th>Field getField(name)</th><th>根据字段名获取某个public的field（包括父类）</th></tr></thead><tbody><tr><td>Field getDeclaredField(name)</td><td>根据字段名获取当前类的某个field（不包括父类）<del>private也可获取</del></td></tr><tr><td>Field[] getFields()</td><td>获取所有public的field（包括父类）</td></tr><tr><td>Field[] getDeclaredFields()</td><td>获取当前类的所有field（不包括父类）</td></tr></tbody></table><h3 id="1-2-2-Field对象包含了一个字段的所有信息"><a href="#1-2-2-Field对象包含了一个字段的所有信息" class="headerlink" title="1.2.2  Field对象包含了一个字段的所有信息"></a>1.2.2  <code>Field</code>对象包含了一个字段的所有信息</h3><table><thead><tr><th>getName()</th><th>返回字段名称，例如，<code>&quot;name&quot;</code></th></tr></thead><tbody><tr><td>getType()</td><td>返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code></td></tr><tr><td>getModifiers()</td><td>返回字段的修饰符<del>它是一个<code>int</code>，不同的bit表示不同的含义</del></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类的value字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取字段信息</span></span><br><span class="line">Field f = String.class.getDeclaredField("value");</span><br><span class="line">f.getName(); <span class="comment">// "value"</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-获取字段值-Field-get-Object"><a href="#1-2-3-获取字段值-Field-get-Object" class="headerlink" title="1.2.3 获取字段值 Field.get(Object)"></a>1.2.3 获取字段值 <code>Field.get(Object)</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">//对于私有字段，需要setAccessible(true)</span></span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-设置字段值Field-set-Object-Object"><a href="#1-2-4-设置字段值Field-set-Object-Object" class="headerlink" title="1.2.4 设置字段值Field.set(Object, Object)"></a>1.2.4 设置字段值<code>Field.set(Object, Object)</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个Object参数是指定的实例，第二个Object参数是待修改的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">"Xiao Hong"</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Hong"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-调用方法"><a href="#1-3-调用方法" class="headerlink" title="1.3 调用方法"></a>1.3 调用方法</h2><h3 id="1-3-1-获取Method信息"><a href="#1-3-1-获取Method信息" class="headerlink" title="1.3.1 获取Method信息"></a>1.3.1 获取<code>Method</code>信息</h3><table><thead><tr><th>Method getMethod(name, Class…)</th><th>获取某个<code>public</code>的<code>Method</code>（包括父类）</th></tr></thead><tbody><tr><td>Method getDeclaredMethod(name, Class…)</td><td>获取当前类的某个<code>Method</code>（不包括父类）</td></tr><tr><td>Method[] getMethods()</td><td>获取所有<code>public</code>的<code>Method</code>（包括父类）</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>获取当前类的所有<code>Method</code>（不包括父类）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getScore"</span>, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getName"</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">"getGrade"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">//public int Student.getScore(java.lang.String)</span></span><br><span class="line"><span class="comment">//public java.lang.String Person.getName()</span></span><br><span class="line"><span class="comment">//private int Student.getGrade(int)</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-Method对象包含一个方法的所有信息"><a href="#1-3-2-Method对象包含一个方法的所有信息" class="headerlink" title="1.3.2 Method对象包含一个方法的所有信息"></a>1.3.2 <code>Method</code>对象包含一个方法的所有信息</h3><table><thead><tr><th>getName()</th><th>返回方法名称，例如：<code>&quot;getScore&quot;</code></th></tr></thead><tbody><tr><td>getReturnType()</td><td>返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code></td></tr><tr><td>getParameterTypes()</td><td>返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code></td></tr><tr><td>getModifiers()</td><td>返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义</td></tr></tbody></table><h3 id="1-3-3-方法调用"><a href="#1-3-3-方法调用" class="headerlink" title="1.3.3 方法调用"></a>1.3.3 方法调用</h3><h4 id="1-3-3-1-调用一般方法-invoke-实例对象，方法参数"><a href="#1-3-3-1-调用一般方法-invoke-实例对象，方法参数" class="headerlink" title="1.3.3.1 调用一般方法[invoke(实例对象，方法参数)]"></a>1.3.3.1 调用一般方法[<code>invoke(实例对象，方法参数)</code>]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射来调用substring方法</span></span><br><span class="line"><span class="comment">//单个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">"Hello world"</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod("substring", int.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多个参数之间用,隔开</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">"Hello world"</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod("substring", int.class, int.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-2-调用静态方法-invoke-null，方法参数"><a href="#1-3-3-2-调用静态方法-invoke-null，方法参数" class="headerlink" title="1.3.3.2 调用静态方法[invoke(null，方法参数)]"></a>1.3.3.2 调用静态方法[<code>invoke(null，方法参数)</code>]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null</span></span><br><span class="line"><span class="comment">//调用Integer.parseInt(String)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod("parseInt", String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">"12345"</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-3-调用非public方法-Method-setAccessible-true"><a href="#1-3-3-3-调用非public方法-Method-setAccessible-true" class="headerlink" title="1.3.3.3 调用非public方法[Method.setAccessible(true)]"></a>1.3.3.3 调用非<code>public</code>方法[<code>Method.setAccessible(true)</code>]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">"Bob"</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-多态-遵循多态原则"><a href="#1-3-4-多态-遵循多态原则" class="headerlink" title="1.3.4 多态[遵循多态原则]"></a>1.3.4 多态[遵循多态原则]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod("hello");</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">//Student:hello </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）</span></span><br><span class="line">Method m = Person.class.getMethod("hello");</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="1-4-调用构造方法"><a href="#1-4-调用构造方法" class="headerlink" title="1.4 调用构造方法"></a>1.4 调用构造方法</h2><h3 id="1-4-1-获取Constructor对象"><a href="#1-4-1-获取Constructor对象" class="headerlink" title="1.4.1 获取Constructor对象"></a>1.4.1 获取<code>Constructor</code>对象</h3><table><thead><tr><th>getConstructor(Class…)</th><th>获取某个<code>public</code>的<code>Constructor</code></th></tr></thead><tbody><tr><td>getDeclaredConstructor(Class…)</td><td>获取某个<code>Constructor</code></td></tr><tr><td>getConstructors()</td><td>获取所有<code>public</code>的<code>Constructor</code></td></tr><tr><td>getDeclaredConstructors()</td><td>获取所有<code>Constructor</code></td></tr></tbody></table><h3 id="1-4-2-创建实例对象newInstance"><a href="#1-4-2-创建实例对象newInstance" class="headerlink" title="1.4.2 创建实例对象newInstance()"></a>1.4.2 创建实例对象<code>newInstance()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">"456"</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//即便不获取Constructor对象,直接通过xxx.class.newInstance()也是可以的。但这样的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3-调用非-public-的Constructor-Constructor-setAccessible-true"><a href="#1-4-3-调用非-public-的Constructor-Constructor-setAccessible-true" class="headerlink" title="1.4.3 调用非 public 的Constructor[Constructor.setAccessible(true)]"></a>1.4.3 调用非 <code>public</code> 的<code>Constructor</code>[<code>Constructor.setAccessible(true)</code>]</h3><blockquote><p><code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败</p></blockquote><h3 id="1-4-4-无多态问题"><a href="#1-4-4-无多态问题" class="headerlink" title="1.4.4 无多态问题"></a>1.4.4 无多态问题</h3><blockquote><p><code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题</p></blockquote><h2 id="1-5-获取继承关系"><a href="#1-5-获取继承关系" class="headerlink" title="1.5 获取继承关系"></a>1.5 获取继承关系</h2><h3 id="1-5-1-获取父类的Class-Class-getSuperclass"><a href="#1-5-1-获取父类的Class-Class-getSuperclass" class="headerlink" title="1.5.1 获取父类的Class[Class.getSuperclass()]"></a>1.5.1 获取父类的Class[<code>Class.getSuperclass()</code>]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer的父类类型是Number，Number的父类是Object，Object的父类是null。除Object外，其他任何非interface的Class都必定存在一个父类类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line">    <span class="comment">//class java.lang.Number </span></span><br><span class="line">    <span class="comment">//class java.lang.Object </span></span><br><span class="line">    <span class="comment">//null</span></span><br></pre></td></tr></table></figure><h3 id="1-5-2-获取interface-Class-getInterfaces"><a href="#1-5-2-获取interface-Class-getInterfaces" class="headerlink" title="1.5.2 获取interface[Class.getInterfaces()]"></a>1.5.2 获取interface[<code>Class.getInterfaces()</code>]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line">    <span class="comment">//interface java.lang.Comparable </span></span><br><span class="line">    <span class="comment">//interface java.lang.constant.Constable </span></span><br><span class="line">    <span class="comment">//interface java.lang.constant.ConstantDesc</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>()</span>;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">//interface java.io.Serializable </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Integer的父类是Number，Number实现的接口是java.io.Serializable</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*1.对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()</span></span><br><span class="line"><span class="comment">*2.如果一个类没有实现任何interface，那么getInterfaces()返回空数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(java.io.DataInputStream<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>; </span><br><span class="line"><span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line"></span><br><span class="line">System.out.println(java.io.Closeable<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>; </span><br><span class="line"><span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><h3 id="1-5-3-继承关系instanceof"><a href="#1-5-3-继承关系instanceof" class="headerlink" title="1.5.3 继承关系instanceof"></a>1.5.3 继承关系<code>instanceof</code></h3><table><thead><tr><th><code>instanceof</code></th><th>一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符</th></tr></thead><tbody><tr><td><code>isAssignableFrom()</code></td><td>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//instanceof</span></span><br><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//isAssignableFrom()</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Number</span>.<span class="title">class</span>)</span>; <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h1 id="2-日期与时间"><a href="#2-日期与时间" class="headerlink" title="2.日期与时间"></a>2.日期与时间</h1><h1 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3.多线程"></a>3.多线程</h1><blockquote><p>进程和线程:一个<strong>进程</strong>可以包含一个或多个<strong>线程</strong>，但至少会有一个<strong>线程</strong>。即进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程</p></blockquote><blockquote><p>多进程缺点：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul></blockquote><blockquote><p>多进程优点：</p><ul><li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</li></ul></blockquote><h2 id="3-1-创建新线程"><a href="#3-1-创建新线程" class="headerlink" title="3.1 创建新线程"></a>3.1 创建新线程</h2><blockquote><p>1.继承Thread类</p><p>2.实现Runnable接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda语法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-run-和start"><a href="#3-1-1-run-和start" class="headerlink" title="3.1.1 run()和start()"></a>3.1.1 <code>run()</code>和<code>start()</code></h3><blockquote><p>调用<code>Thread</code>实例的<code>start()</code>方法才是启动新线程</p><ul><li>查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的</li></ul></blockquote><blockquote><p>调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程</p></blockquote><h3 id="3-1-2-线程的优先级"><a href="#3-1-2-线程的优先级" class="headerlink" title="3.1.2 线程的优先级"></a>3.1.2 线程的优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定优先级</span></span><br><span class="line"><span class="comment">//优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</span></span><br><span class="line">Thread.setPriority(<span class="keyword">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure><p>==注意：当一个新的线程启动以后，它就由操作系统调度，程序本身无法确定线程的调度顺序==</p><h2 id="3-2-线程状态"><a href="#3-2-线程状态" class="headerlink" title="3.2  线程状态"></a>3.2  线程状态</h2><table><thead><tr><th align="center">状态</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">New</td><td align="left">新创建的线程，尚未执行</td></tr><tr><td align="center">Runnable</td><td align="left">运行中的线程，正在执行<code>run()</code>方法的Java代码</td></tr><tr><td align="center">Blocked</td><td align="left">运行中的线程，因为某些操作被阻塞而挂起</td></tr><tr><td align="center">Waiting</td><td align="left">运行中的线程，因为某些操作在等待中</td></tr><tr><td align="center">Timed Waiting</td><td align="left">运行中的线程，因为执行<code>sleep()</code>方法正在计时等待</td></tr><tr><td align="center">Terminated</td><td align="left">线程已终止，因为<code>run()</code>方法执行完毕</td></tr></tbody></table><h3 id="3-2-1-线程中止原因"><a href="#3-2-1-线程中止原因" class="headerlink" title="3.2.1 线程中止原因"></a>3.2.1 线程中止原因</h3><table><thead><tr><th>线程正常终止</th><th><code>run()</code>方法执行到<code>return</code>语句返回</th></tr></thead><tbody><tr><td>线程意外终止</td><td><code>run()</code>方法因为未捕获的异常导致线程终止</td></tr><tr><td><del>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止</del></td><td>不推荐使用</td></tr></tbody></table><h3 id="3-2-2-join"><a href="#3-2-2-join" class="headerlink" title="3.2.2   join()"></a>3.2.2   <code>join()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>使用</th><th>解释</th></tr></thead><tbody><tr><td>join()</td><td>对另一个线程对象调用<code>join()</code>方法可以等待其执行结束</td></tr><tr><td>线程结束调用join()</td><td>对已经运行结束的线程调用<code>join()</code>方法会立刻返回</td></tr><tr><td>join(long)</td><td>指定等待时间，超过等待时间线程仍然没有结束就不再等待</td></tr></tbody></table><h2 id="3-3-中断线程interrupt"><a href="#3-3-中断线程interrupt" class="headerlink" title="3.3 中断线程interrupt()"></a>3.3 中断线程<code>interrupt()</code></h2><h1 id="4-注解"><a href="#4-注解" class="headerlink" title="4.注解"></a>4.注解</h1><h2 id="4-1-使用注解"><a href="#4-1-使用注解" class="headerlink" title="4.1 使用注解"></a>4.1 使用注解</h2><blockquote><p>注解<code>Annotation</code></p><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”</p></blockquote><table><thead><tr><th>注解分类</th><th>举例</th><th>举例</th><th>注意</th></tr></thead><tbody><tr><td>1.由编译器使用的注解</td><td><code>@Override</code>让编译器检查该方法是否正确地实现了覆写</td><td><code>@SuppressWarnings</code>告诉编译器忽略此处代码产生的警告</td><td>注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了</td></tr><tr><td>2.由工具处理<code>.class</code>文件使用的注解</td><td>有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能</td><td></td><td>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理</td></tr><tr><td>3.程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解</td><td>一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用</td><td></td><td>这是Java代码读取该注解实现的功能，JVM并不会识别该注解</td></tr></tbody></table><table><thead><tr><th>定义注解中的配置参数，包括：</th></tr></thead><tbody><tr><td>1.所有基本类型</td></tr><tr><td>2.String</td></tr><tr><td>3.枚举类型</td></tr><tr><td>4.基本类型、String以及枚举的数组</td></tr></tbody></table><blockquote><p><code>Tips</code>1.因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值</p><p>2.注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值</p><p>3.大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p><p>如果只写注解，相当于全部使用默认值</p><p>4.如果参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称</p></blockquote><h2 id="4-2-定义注解"><a href="#4-2-定义注解" class="headerlink" title="4.2 定义注解"></a>4.2 定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-1-元注解"><a href="#4-2-1-元注解" class="headerlink" title="4.2.1 元注解"></a>4.2.1 元注解</h3><blockquote><p>有一些注解可以修饰其他注解，这些注解就称为元注解</p></blockquote><table><thead><tr><th>元注解</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><code>@Target</code>^常用^：定义<code>Annotation</code>能够被应用于源码的哪些位置</td><td>类或接口：<code>ElementType.TYPE</code></td><td>字段：<code>ElementType.FIELD</code></td><td>方法：<code>ElementType.METHOD</code></td><td>构造方法：<code>ElementType.CONSTRUCTOR</code></td><td>方法参数：<code>ElementType.PARAMETER</code></td></tr><tr><td><code>@Retention</code>^常用^：定义了<code>Annotation</code>的生命周期</td><td>仅编译期：<code>RetentionPolicy.SOURCE</code></td><td>仅class文件：<code>RetentionPolicy.CLASS</code></td><td>运行期：<code>RetentionPolicy.RUNTIME</code></td><td></td><td></td></tr><tr><td><code>@Repeatable</code>：定义<code>Annotation</code>是否可重复</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>@Inherited</code>：使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组&#123; ElementType.METHOD, ElementType.FIELD &#125;</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">    ElementType.METHOD,</span><br><span class="line">    ElementType.FIELD</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Repeatable应用不是特别广泛</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Reports<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(<span class="title">ElementType</span>.<span class="title">TYPE</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解</span></span><br><span class="line"><span class="meta">@Report</span>(type=<span class="number">1</span>, level=<span class="string">"debug"</span>)</span><br><span class="line"><span class="meta">@Report</span>(type=<span class="number">2</span>, level=<span class="string">"warning"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果一个类用到了@Report</span></span><br><span class="line"><span class="meta">@Report</span>(type=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//它的子类默认也定义了该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-定义Annotation"><a href="#4-2-2-定义Annotation" class="headerlink" title="4.2.2 定义Annotation"></a>4.2.2 定义<code>Annotation</code></h3><table><thead><tr><th>定义<code>Annotation</code>的步骤</th><th>代码举例</th></tr></thead><tbody><tr><td>1.用<code>@interface</code>定义注解</td><td>public @interface Report { }</td></tr><tr><td>2.添加参数、默认值</td><td>public @interface Report {     int type() default 0;     String level() default “info”;     String value() default “”; }</td></tr><tr><td>3.用元注解配置注解</td><td>@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Report {     int type() default 0;     String level() default “info”;     String value() default “”; }</td></tr></tbody></table><blockquote><p><code>Tips</code>：1.把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值</p><p>2.其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code></p></blockquote><h2 id="4-3-处理注解"><a href="#4-3-处理注解" class="headerlink" title="4.3 处理注解"></a>4.3 处理注解</h2><h1 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h1><h1 id="6-集合"><a href="#6-集合" class="headerlink" title="6.集合"></a>6.集合</h1><h1 id="14-计算机网络"><a href="#14-计算机网络" class="headerlink" title="14.计算机网络"></a>14.计算机网络</h1><h2 id="14-1-基础"><a href="#14-1-基础" class="headerlink" title="14.1 基础"></a>14.1 基础</h2><h3 id="14-1-1-IP"><a href="#14-1-1-IP" class="headerlink" title="14.1.1 IP"></a>14.1.1 IP</h3><blockquote><p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<code>127.0.0.1</code>，还有一个IP地址，例如<code>101.202.99.12</code>，可以通过这个IP地址接入网络。</p><p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p><p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP &#x3D; 101.202.99.2</span><br><span class="line">Mask &#x3D; 255.255.255.0</span><br><span class="line">Network &#x3D; IP &amp; Mask &#x3D; 101.202.99.0</span><br></pre></td></tr></table></figure><h3 id="14-1-2-网络模型"><a href="#14-1-2-网络模型" class="headerlink" title="14.1.2 网络模型"></a>14.1.2 网络模型</h3><table><thead><tr><th>OSI</th><th>TCP/IP</th></tr></thead><tbody><tr><td>应用层：提供应用程序之间的通信</td><td>应用层</td></tr><tr><td>表示层：处理数据格式，加解密等等</td><td>应用层</td></tr><tr><td>会话层：负责建立和维护会话</td><td>应用层</td></tr><tr><td>传输层：负责提供端到端的可靠传输</td><td>传输层</td></tr><tr><td>网络层：负责根据目标地址选择路由来传输数据</td><td>IP层</td></tr><tr><td>链路层：负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等</td><td>网络接口层</td></tr><tr><td>物理层：同链路层</td><td>网络接口层</td></tr></tbody></table><h3 id="14-1-3-IP-amp-TCP-amp-UDP"><a href="#14-1-3-IP-amp-TCP-amp-UDP" class="headerlink" title="14.1.3 IP&amp;TCP&amp;UDP"></a>14.1.3 IP&amp;TCP&amp;UDP</h3><table><thead><tr><th>常用协议</th></tr></thead><tbody><tr><td><code>IP协议</code>是一个分组交换，它不保证可靠传输，IP协议只负责发数据包，不保证顺序和正确性</td></tr><tr><td><code>TCP协议</code>是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的。TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据；TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等</td></tr><tr><td><code>UDP协议</code>（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="2020/09/volatile/"/>
      <url>2020/09/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言-初露头角"><a href="#1-引言-初露头角" class="headerlink" title="1.引言-初露头角"></a>1.引言-初露头角</h1><p>​    其实刚开始接触Java时，看到<code>volatile</code>关键字时就不由得头大，当时点进去相关的博文，基本一上来就点题，即<code>保证内存可见性，防止指令重排序</code>，我当时就一菜鸟，每个字能看懂，合在一块就成天书了。当然了，现在来看这句话，的确是简明扼要的点中了<code>JDK5</code>增强以后的<code>volatile</code>所要表示的含义！话不多说，我们一起来看看<code>volatile</code>的秘密吧！</p><p>​    数学题中，一个题目越短，基本上这个题目就越难（别杠啊！打比方而已），为什么？题目越短，你能获取的信息就越少；同样，在Java中，像<code>volatile</code>、<code>synchronized</code>等，仅靠一个关键字就能保证多线程下的安全性，我们想要了解它，就必须向下深挖。所以在深入volatile之前，我们来谈谈几个重要的知识，<code>Java 的内存模型（JMM）</code>、<code>重排序</code>以及<code>happens-before规则</code>。</p><blockquote><p>Tips:因为涉及到底层的知识较多，博文篇幅可能较长。为了方便阅读，我会把相应的知识点单独成篇，在本篇里对相应技术点进行精简，只做结论性介绍。想要了解更多对应知识点，进入对应专栏阅读即可！</p></blockquote><h1 id="2-JMM"><a href="#2-JMM" class="headerlink" title="2.JMM"></a>2.JMM</h1><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务(一) 分布式事务</title>
      <link href="2020/05/%E4%BA%8B%E5%8A%A1(%E4%B8%80)Distributed%20Transactions/"/>
      <url>2020/05/%E4%BA%8B%E5%8A%A1(%E4%B8%80)Distributed%20Transactions/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解开发手册</title>
      <link href="2020/09/Spring-Annoatation/"/>
      <url>2020/09/Spring-Annoatation/</url>
      
        <content type="html"><![CDATA[<h1 id="1-组件注册"><a href="#1-组件注册" class="headerlink" title="1.组件注册"></a>1.组件注册</h1><h2 id="1-1-包扫描-ComponentScan-组件标注注解-Component、-Service、-Controller、-Repository-gt-自定义类"><a href="#1-1-包扫描-ComponentScan-组件标注注解-Component、-Service、-Controller、-Repository-gt-自定义类" class="headerlink" title="1.1 包扫描@ComponentScan+组件标注注解@Component、@Service、@Controller、@Repository-&gt;自定义类"></a>1.1 包扫描<code>@ComponentScan</code>+组件标注注解<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>-&gt;自定义类</h2><ul><li><code>@ComponentScan  value</code>:指定要扫描的包，默认为注解所在包及其子包<ul><li><code>excludeFilters = Filter[]</code>：指定扫描的时候按照什么规则排除哪些组件</li><li><code>includeFilters = Filter[]</code> ：指定扫描的时候只需要包含哪些组件，需将<code>useDefaultFilters</code>置false<ul><li><code>FilterType.ANNOTATION</code>：按照注解</li><li><code>FilterType.ASSIGNABLE_TYPE</code>：按照给定的类型</li><li><code>FilterType.ASPECTJ</code>：使用ASPECTJ表达式</li><li><code>FilterType.REGEX</code>：使用正则指定</li><li><code>FilterType.CUSTOM</code>：使用自定义规则(实现<code>TypeFilter</code>)</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScans</span>(</span><br><span class="line">value = &#123;</span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.onechat"</span>,includeFilters = &#123;</span><br><span class="line">                    <span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                    @<span class="title">Filter</span>(<span class="title">type</span></span>=FilterType.ASSIGNABLE_TYPE,classes=&#123;BookService<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                    @<span class="title">Filter</span>(<span class="title">type</span></span>=FilterType.CUSTOM,classes=&#123;MyTypeFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">&#125;,<span class="title">useDefaultFilters</span> </span>= <span class="keyword">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * metadataReader：读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment"> * metadataReaderFactory:可以获取到其他任何类信息的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//获取当前类注解的信息</span></span><br><span class="line">AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line"><span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line">ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line"><span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line">Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">String className = classMetadata.getClassName();</span><br><span class="line">System.out.println(<span class="string">"---&gt;"</span>+className);</span><br><span class="line"><span class="keyword">if</span>(className.contains(<span class="string">"er"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-Bean"><a href="#1-2-Bean" class="headerlink" title="1.2@Bean"></a>1.2<code>@Bean</code></h2><p>定义：给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id</p><p>用途：主要用于导入的第三方包里面的组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"hanmeimei"</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-1-Conditional-Condition"><a href="#1-2-1-Conditional-Condition" class="headerlink" title="1.2.1 @Conditional({Condition})"></a>1.2.1 <code>@Conditional({Condition})</code></h3><p>定义:按照一定的条件判断，满足条件给容器中注册bean；也可以定义在类上，在类中组件统一设置，表示满足当前条件，这个类中配置的所有bean注册才能生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional</span>(LinuxCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@Bean("linus")</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>, <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否linux系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConditionContext：判断条件能使用的上下文（环境）</span></span><br><span class="line"><span class="comment"> * AnnotatedTypeMetadata：注释信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO是否linux系统</span></span><br><span class="line"><span class="comment">//1、能获取到ioc使用的beanfactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line"><span class="comment">//2、获取类加载器</span></span><br><span class="line">ClassLoader classLoader = context.getClassLoader();</span><br><span class="line"><span class="comment">//3、获取当前环境信息</span></span><br><span class="line">Environment environment = context.getEnvironment();</span><br><span class="line"><span class="comment">//4、获取到bean定义的注册类</span></span><br><span class="line">BeanDefinitionRegistry registry = context.getRegistry();</span><br><span class="line">String property = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line"><span class="comment">//可以判断容器中的bean注册情况，也可以给容器中注册bean</span></span><br><span class="line"><span class="keyword">boolean</span> definition = registry.containsBeanDefinition(<span class="string">"person"</span>);</span><br><span class="line"><span class="keyword">if</span>(property.contains(<span class="string">"linux"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////类中组件统一设置。满足当前条件，这个类中配置的所有bean注册才能生效；</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;LinuxCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-Scope"><a href="#1-2-2-Scope" class="headerlink" title="1.2.2 @Scope"></a>1.2.2 <code>@Scope</code></h3><blockquote><p>调整作用域</p></blockquote><ul><li>prototype：多实例的，ioc容器启动并不会去调用方法创建对象放在容器中，每次获取的时候才会调用方法创建对象</li><li>singleton：单实例的（默认值），ioc容器启动会调用方法创建对象放到ioc容器中，以后每次获取就是直接从容器中拿</li></ul><h3 id="1-2-3-Lazy"><a href="#1-2-3-Lazy" class="headerlink" title="1.2.3 @Lazy"></a>1.2.3 <code>@Lazy</code></h3><blockquote><p>懒加载:对于单实例bean来说，默认在容器启动的时候创建对象，使用<code>@Lazy</code>后，容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化</p></blockquote><h2 id="1-3-Import"><a href="#1-3-Import" class="headerlink" title="1.3 @Import"></a>1.3 <code>@Import</code></h2><p>作用：快速给容器中导入一个组件</p><h3 id="1-3-1-Import-类名"><a href="#1-3-1-Import-类名" class="headerlink" title="1.3.1 Import(类名)"></a>1.3.1 <code>Import(类名)</code></h3><blockquote><p>导入组件，id默认是组件的全类名</p></blockquote><h3 id="1-3-2-ImportSelector"><a href="#1-3-2-ImportSelector" class="headerlink" title="1.3.2 ImportSelector"></a>1.3.2 <code>ImportSelector</code></h3><blockquote><p>实现<code>ImportSelector</code>接口，自定义逻辑返回需要导入的组件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义逻辑返回需要导入的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值:就是到导入到容器中的组件全类名</span></span><br><span class="line"><span class="comment">//AnnotationMetadata:当前---标注@Import注解的类---的所有注解信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//importingClassMetadata</span></span><br><span class="line"><span class="comment">//方法不要返回null值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.onechat.bean.Blue"</span>,<span class="string">"com.onechat.bean.Yellow"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-ImportBeanDefinitionRegister"><a href="#1-3-3-ImportBeanDefinitionRegister" class="headerlink" title="1.3.3 ImportBeanDefinitionRegister"></a>1.3.3 <code>ImportBeanDefinitionRegister</code></h3><blockquote><p>实现<code>ImportBeanDefinitionRegistrar</code>接口，手动注册Bean，可以加入逻辑，判断是否满足条件注册</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationMetadata：当前类的注解信息</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry:BeanDefinition注册类；</span></span><br><span class="line"><span class="comment"> * 把所有需要添加到容器中的bean；调用</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry.registerBeanDefinition手工注册进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> definition = registry.containsBeanDefinition(<span class="string">"com.onechat.bean.Red"</span>);</span><br><span class="line"><span class="keyword">boolean</span> definition2 = registry.containsBeanDefinition(<span class="string">"com.onechat.bean.Blue"</span>);</span><br><span class="line"><span class="keyword">if</span>(definition &amp;&amp; definition2)&#123;</span><br><span class="line"><span class="comment">//指定Bean定义信息；（Bean的类型，Bean。。。）</span></span><br><span class="line">RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//注册一个Bean，指定bean名</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"rainBow"</span>, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-Spring定义的FactoryBean"><a href="#1-4-Spring定义的FactoryBean" class="headerlink" title="1.4 Spring定义的FactoryBean"></a>1.4 Spring定义的<code>FactoryBean</code></h2><h3 id="1-4-1-默认获取到的是工厂bean调用getObject创建的对象"><a href="#1-4-1-默认获取到的是工厂bean调用getObject创建的对象" class="headerlink" title="1.4.1 默认获取到的是工厂bean调用getObject创建的对象"></a>1.4.1 默认获取到的是工厂bean调用<code>getObject</code>创建的对象</h3><h3 id="1-4-2-在id前面加个-amp-标识即能获取到FactoryBean自身"><a href="#1-4-2-在id前面加个-amp-标识即能获取到FactoryBean自身" class="headerlink" title="1.4.2 在id前面加个&amp;标识即能获取到FactoryBean自身"></a>1.4.2 在id前面加个<code>&amp;</code>标识即能获取到FactoryBean自身</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Spring定义的FactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//返回一个Color对象，这个对象会添加到容器中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"ColorFactoryBean...getObject..."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> Color<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是单例？</span></span><br><span class="line"><span class="comment">//true：这个bean是单实例，在容器中保存一份</span></span><br><span class="line"><span class="comment">//false：多实例，每次获取都会创建一个新的bean；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h1><p>bean的生命周期：bean创建—初始化—-销毁的过程</p><p>构造（对象创建）：</p><ul><li><p>单实例：在容器启动的时候创建对象</p></li><li><p>多实例：在每次获取的时候创建对象</p></li></ul><h2 id="2-1-容器管理bean的生命周期"><a href="#2-1-容器管理bean的生命周期" class="headerlink" title="2.1 容器管理bean的生命周期"></a>2.1 容器管理bean的生命周期</h2><p>​    我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法</p><h3 id="2-1-1-指定初始化init-method和销毁方法destroy-method"><a href="#2-1-1-指定初始化init-method和销毁方法destroy-method" class="headerlink" title="2.1.1 指定初始化init-method和销毁方法destroy-method"></a>2.1.1 指定初始化<code>init-method</code>和销毁方法<code>destroy-method</code></h3><p>通过<code>@Bean</code>指定<code>init-method</code>和<code>destroy-method</code>，类似于在xml文件中配置&lt;bean id=”” class=”” `nit-method=”” destroy-method=””/&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>,destroyMethod=<span class="string">"detory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"car constructor..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"car ... init..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detory</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"car ... detory..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-通过让Bean实现InitializingBean和DisposableBean"><a href="#2-1-2-通过让Bean实现InitializingBean和DisposableBean" class="headerlink" title="2.1.2 通过让Bean实现InitializingBean和DisposableBean"></a>2.1.2 通过让Bean实现<code>InitializingBean</code>和<code>DisposableBean</code></h3><p><code>InitializingBean</code>:定义初始化逻辑</p><p><code>DisposableBean</code>:定义销毁逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"cat...destroy..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"cat...afterPropertiesSet..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-使用JSR250中-PostConstruct和-PreDestroy"><a href="#2-1-3-使用JSR250中-PostConstruct和-PreDestroy" class="headerlink" title="2.1.3 使用JSR250中@PostConstruct和@PreDestroy"></a>2.1.3 使用<code>JSR250</code>中<code>@PostConstruct</code>和<code>@PreDestroy</code></h3><p><code>@PostConstruct</code>：在bean创建完成并且属性赋值完成；来执行初始化方法</p><p><code>@PreDestroy</code>：在容器销毁bean之前通知我们进行清理工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog constructor..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象创建并赋值之后调用</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog....@PostConstruct..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器移除对象之前</span></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detory</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog....@PreDestroy..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-实现BeanPostProcessor"><a href="#2-1-4-实现BeanPostProcessor" class="headerlink" title="2.1.4 实现BeanPostProcessor"></a>2.1.4 实现<code>BeanPostProcessor</code></h3><p><code>BeanPostProcessor</code>[interface]：bean的后置处理器，在bean初始化前后进行一些处理工作</p><ul><li><p><code>postProcessBeforeInitialization</code>:在初始化之前工作</p></li><li><p><code>postProcessAfterInitialization</code>:在初始化之后工作</p></li></ul><p><img src="https://gitee.com/fagefocus/images/raw/mdPicture//image-20200903121138908.png" alt="image-20200903121138908"></p><p>从图中可以看到，Spring底层对BeanPostProcess接口有大量使用：</p><ul><li><p>bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async,都是由xxx BeanPostProcessor来完成，例如：</p><ul><li><p><code>InitDestroyAnnotationBeanPostProcessor</code>会对<code>@PostConstructor</code>和<code>@PreDestroy</code>注解进行解析来达到容器的初始化和销毁方法的执行</p></li><li><p><code>ApplicationContextAwareProcessor</code>会在实现了<code>ApplicationContextAware</code>接口的bean里面</p><p>通过<code>((ApplicationContextAware) bean).setApplicationContext(this.applicationContext)</code>将容器注入到bean中</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器：初始化前后进行处理工作</span></span><br><span class="line"><span class="comment"> * 将后置处理器加入到容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"postProcessBeforeInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"postProcessAfterInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，一但返回null，跳出for循环，不会执行后面的  BeanPostProcessor.postProcessorsBeforeInitialization.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     BeanPostProcessor原理</span></span><br><span class="line"><span class="comment">     populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值</span></span><br><span class="line"><span class="comment">     initializeBean</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">         applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span></span><br><span class="line"><span class="comment">         invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化</span></span><br><span class="line"><span class="comment">         applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020/08/23/JMM之Happens-before Order</title>
      <link href="2020/08/23/JMM%E4%B9%8BHappens-before%20Order/"/>
      <url>2020/08/23/JMM%E4%B9%8BHappens-before%20Order/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM之Happens-before-Order"><a href="#JMM之Happens-before-Order" class="headerlink" title="JMM之Happens-before Order"></a>JMM之<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5" target="_blank" rel="noopener">Happens-before Order</a></h1><h2 id="1-内存可见性发生原因？"><a href="#1-内存可见性发生原因？" class="headerlink" title="1.内存可见性发生原因？"></a>1.内存可见性发生原因？</h2><blockquote><p>电脑多CPU并且都有缓存导致</p></blockquote><h2 id="2-关于-happens-before-有以下8条规则？"><a href="#2-关于-happens-before-有以下8条规则？" class="headerlink" title="2.关于 happens-before,有以下8条规则？"></a>2.关于 happens-before,有以下8条规则？</h2><table><thead><tr><th>原则</th><th></th></tr></thead><tbody><tr><td>单线程Happens-Before原则</td><td>在同一个线程中，书写在前面的操作happen-before后面的操作</td></tr><tr><td>锁的Happens-Before原则</td><td>同一个锁的unlock操作happen-before此锁的lock操作</td></tr><tr><td>volatile的Happens-Before原则</td><td>对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)</td></tr><tr><td>Happens-Before的传递性原则</td><td>如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作</td></tr><tr><td>线程启动的Happens-Before原则</td><td>同一个线程的start方法happen-before此线程的其它方法</td></tr><tr><td>线程中断的Happens-Before原则</td><td>对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码</td></tr><tr><td>线程终结的Happens-Before原则</td><td>线程中的所有操作都happen-before线程的终止检测</td></tr><tr><td>对象创建的Happens-Before原则</td><td>一个对象的初始化完成先于他的finalize方法调用</td></tr></tbody></table><p>—————————————————-<a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">详情请见</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="2020/07/jvm_manual/"/>
      <url>2020/07/jvm_manual/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_45759791/article/details/107322503" target="_blank" rel="noopener">第一章、JVM和Java体系架构</a></p><p><a href="https://blog.csdn.net/weixin_45759791/article/details/107322692" target="_blank" rel="noopener">第二章、类加载子系统</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020/04/aboutBlog</title>
      <link href="2020/04/aboutBlog/"/>
      <url>2020/04/aboutBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="建站流程？"><a href="#建站流程？" class="headerlink" title="建站流程？"></a>建站流程？</h1><p>具体可参考<a href="www.hexocn.cn">Hexo官网</a></p><p>(1) 基础环境搭建(安装node、git和npm/cnpm),具体操作参考官网，不做演示</p><p>(2) 博客环境搭建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g 表示全局安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cnpm install -g hexo-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> your_blog_name 表示博客根目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init your_blog_name</span></span><br></pre></td></tr></table></figure><h1 id="关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？"><a href="#关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？" class="headerlink" title="关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？"></a>关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？</h1><p>(1) 修改hexo中 _config.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="comment"># root 后面写你 github 仓库的名字</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/XXX.github.io</span></span><br></pre></td></tr></table></figure><p>(2) 重新上传</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次云服务器被攻击&amp;MySQL访问权限修改</title>
      <link href="2020/07/ecsAttacked/"/>
      <url>2020/07/ecsAttacked/</url>
      
        <content type="html"><![CDATA[<h1 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h1><p><code>To recover your lost Database and avoid leaking it: Send us 0.06 Bitcoin (BTC) to our Bitcoin address 1DR7CaR2Dm5bfQ3615UeruZe6uNTvtvXUW and contact us by Email with your Server IP or Domain name and a Proof of Payment. If you are unsure if we have your data, contact us and we will send you a proof. Your Database is downloaded and backed up on our servers. Backups that we have right now: onechat. If we dont receive your payment in the next 10 Days, we will make your database public or use them otherwise.</code></p><p>由于图方便，服务器安装MySQL时使用的都是默认的用户名密码以及端口，对于权限问题也没有过多设置导致数据库易被攻击</p><h2 id="1-未雨绸缪"><a href="#1-未雨绸缪" class="headerlink" title="1.未雨绸缪"></a>1.未雨绸缪</h2><blockquote><p>数据库安装时将端口、用户名、密码统一修改</p></blockquote><hr><h2 id="2-亡羊补牢"><a href="#2-亡羊补牢" class="headerlink" title="2.亡羊补牢"></a>2.亡羊补牢</h2><p>此处@<a href="https://blog.csdn.net/weixin_42031119/article/details/104559644?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">从入门到放弃</a>，感谢他的帮助</p><h3 id="2-1-修改访问权限"><a href="#2-1-修改访问权限" class="headerlink" title="2.1 修改访问权限"></a>2.1 修改访问权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入数据库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用mysql特殊数据库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> use mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入后查看user表</span></span><br><span class="line">select user,host from user;</span><br></pre></td></tr></table></figure><blockquote><p>显示出来的表，如果看到你的user下你的默认用户root，看到他的host是%的话。那这就是一个问题所在。<br><strong>host代表允许访问的主机地址，而%为全部允许</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将其修改</span><br><span class="line">update user set host&#x3D;&#39;localhost&#39; where user &#x3D; &#39;root&#39;;</span><br><span class="line"># 刷新缓存，让配置生效</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><blockquote><p>修改之后只能由localhost才能访问，即服务器的host</p><p>这时就需要添加新的user和host</p></blockquote><table><thead><tr><th align="center">user</th><th align="center">host</th></tr></thead><tbody><tr><td align="center">your_user_name</td><td align="center">your_ip</td></tr><tr><td align="center">root</td><td align="center">localhost</td></tr><tr><td align="center">mysql.sys</td><td align="center">localhost</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><blockquote><p>MySQL 5.1 版本之后，给user表中添加新的数据时，不能采用<code>insert into</code>的方式</p><p>会出现<code>Field &#39;ssl_cipher&#39; doesn&#39;t have a default value</code>错误</p></blockquote><ul><li>在<code>mysql</code>的<code>user</code>表中增加连接用户帐号</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用GRANT语句进行授权</span></span><br><span class="line"> GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost' IDENTIFIED BY 'password';</span><br><span class="line"><span class="meta"> #</span><span class="bash"> “username”替换为将要授权的用户名，比如clientusr</span></span><br><span class="line"><span class="meta"> #</span><span class="bash"> “password”替换为clientusr设置的密码</span></span><br></pre></td></tr></table></figure><ul><li>可访问数据表授权</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建好帐户之后，就开始给上面的common user进行数据表授权，步骤3中增加的连接用户默认权限都是“N”的，必须在db表中为该帐户授权，允许其访问专用数据库，当然超级用户就不说了。</span><br><span class="line"># 使用下面语句：</span><br><span class="line"></span><br><span class="line">GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP ON yourdbname.tablename TO &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line"></span><br><span class="line"># 本语句中的权限根据实际需要确定：</span><br><span class="line"># &quot;tablename&quot;替换为授权访问的数据表table名</span><br><span class="line"># &quot;username&quot;是步骤2授权用户名</span><br><span class="line"># &quot;password&quot;是步骤2授权用户的设置密码</span><br><span class="line"># 这样就为该用户授予了对某数据表的SELECT, INSERT, UPDATE, DELETE, CAREATE, DROP权限</span><br><span class="line"># 刷新 生效授权</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><h3 id="2-2-修改端口号"><a href="#2-2-修改端口号" class="headerlink" title="2.2 修改端口号"></a>2.2 修改端口号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p</span></span><br><span class="line">show global variables like 'port';</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 port=3306 为其它</span></span><br><span class="line">vi /etc/my.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">service mysql restart || docker restart your_mysql_name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样相关配置文件以及连接客户端都需要统一更改</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-复旧如新"><a href="#3-复旧如新" class="headerlink" title="3. 复旧如新"></a>3. 复旧如新</h2><p>此处@<a href="https://zhuanlan.zhihu.com/p/71758831" target="_blank" rel="noopener">巴啦啦小魔仙人掌</a>，感谢他的帮助</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之观察者模式</title>
      <link href="2020/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/06/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式之工厂模式</title>
      <link href="2020/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>2020/06/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>结论</p><table><thead><tr><th>普通工厂</th><th>抽象工厂</th></tr></thead><tbody><tr><td>普通工厂使用的是继承，利用普通工厂创建对象需要在基类上扩展一个类，并覆盖其工厂方法，即通过子类来创建对象，此时则无需关心实例化的是何种具体类型，关心其抽象类型(基类)即可</td><td>抽象工厂通过对象的组合，</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="2020/05/vue-manual/"/>
      <url>2020/05/vue-manual/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
