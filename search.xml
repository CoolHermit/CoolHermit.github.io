<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo的搜索实现之 hexo-generator-search</title>
      <link href="2020/10/2020-10-08-Hexo%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E4%B9%8B-hexo-generator-search/"/>
      <url>2020/10/2020-10-08-Hexo%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%E4%B9%8B-hexo-generator-search/</url>
      
        <content type="html"><![CDATA[<p>转载于<a href="https://www.hahack.com/codes/local-search-engine-for-hexo/" target="_blank" rel="noopener">https://www.hahack.com/codes/local-search-engine-for-hexo/</a></p><h2 id="1-安装和配置-hexo-generator-search"><a href="#1-安装和配置-hexo-generator-search" class="headerlink" title="1. 安装和配置 hexo-generator-search"></a>1. 安装和配置 hexo-generator-search</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install --save hexo-generator-search</span></span><br></pre></td></tr></table></figure><p>然后，在站点根 <code>_config.yml</code> 里头添加设置项：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>path</strong> - 指定生成的索引数据的文件名。默认为 search.xml 。</li><li>field - 指定索引数据的生成范围。可选值包括：<ul><li><strong>post</strong> - 只生成博客文章（post）的索引（默认）；</li><li><strong>page</strong> - 只生成其他页面（page）的索引；</li><li><strong>all</strong> - 生成所有文章和页面的索引。</li></ul></li></ul><p>完成后，可以试试访问预览站点的 search.xml 页面。例如，如果你的预览站点域名是 <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000</a> ，那么可以访问 <a href="http://0.0.0.0:4000/search.xml" target="_blank" rel="noopener">http://0.0.0.0:4000/search.xml</a> 看看是否会打开一个 xml 页面。</p><h2 id="2-编写搜索界面"><a href="#2-编写搜索界面" class="headerlink" title="2. 编写搜索界面"></a>2. 编写搜索界面</h2><p>搜索界面由一个输入框（input）和一个用于动态插入搜索结果的 div 组成。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"site_search"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"local-search-input"</span> <span class="attr">name</span>=<span class="string">"q"</span> <span class="attr">results</span>=<span class="string">"0"</span> <span class="attr">placeholder</span>=<span class="string">"search my blog..."</span> <span class="attr">class</span>=<span class="string">"form-control"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"local-search-result"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你也可以根据自己的喜好写成其他的形式，例如把用于插入结果的 div 移动到页面的其他地方。</p><h2 id="3-实现本地搜索函数"><a href="#3-实现本地搜索函数" class="headerlink" title="3. 实现本地搜索函数"></a>3. 实现本地搜索函数</h2><p>接下来编写一个 search.js 脚本，用来实现基于 search.xml 的本地检索函数 searchFunc ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> searchFunc = <span class="function"><span class="keyword">function</span>(<span class="params">path, search_id, content_id</span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: path,</span><br><span class="line">        dataType: <span class="string">"xml"</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params"> xmlResponse </span>) </span>&#123;</span><br><span class="line">            <span class="comment">// get the contents from search data</span></span><br><span class="line">            <span class="keyword">var</span> datas = $( <span class="string">"entry"</span>, xmlResponse ).map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    title: $( <span class="string">"title"</span>, <span class="keyword">this</span> ).text(),</span><br><span class="line">                    content: $(<span class="string">"content"</span>,<span class="keyword">this</span>).text(),</span><br><span class="line">                    url: $( <span class="string">"url"</span> , <span class="keyword">this</span>).text()</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;).get();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> $input = <span class="built_in">document</span>.getElementById(search_id);</span><br><span class="line">            <span class="keyword">var</span> $resultContent = <span class="built_in">document</span>.getElementById(content_id);</span><br><span class="line"></span><br><span class="line">            $input.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> str=<span class="string">'&lt;ul class=\"search-result-list\"&gt;'</span>;                </span><br><span class="line">                <span class="keyword">var</span> keywords = <span class="keyword">this</span>.value.trim().toLowerCase().split(<span class="regexp">/[\s\-]+/</span>);</span><br><span class="line">                $resultContent.innerHTML = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.value.trim().length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// perform local searching</span></span><br><span class="line">                datas.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> isMatch = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">var</span> content_index = [];</span><br><span class="line">                    <span class="keyword">var</span> data_title = data.title.trim().toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>).toLowerCase();</span><br><span class="line">                    <span class="keyword">var</span> data_url = data.url;</span><br><span class="line">                    <span class="keyword">var</span> index_title = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> index_content = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">var</span> first_occur = <span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">// only match artiles with not empty titles and contents</span></span><br><span class="line">                    <span class="keyword">if</span>(data_title != <span class="string">''</span> &amp;&amp; data_content != <span class="string">''</span>) &#123;</span><br><span class="line">                        keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword, i</span>) </span>&#123;</span><br><span class="line">                            index_title = data_title.indexOf(keyword);</span><br><span class="line">                            index_content = data_content.indexOf(keyword);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>( index_title &lt; <span class="number">0</span> &amp;&amp; index_content &lt; <span class="number">0</span> )&#123;</span><br><span class="line">                                isMatch = <span class="literal">false</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (index_content &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                    index_content = <span class="number">0</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                                    first_occur = index_content;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// show search results</span></span><br><span class="line">                    <span class="keyword">if</span> (isMatch) &#123;</span><br><span class="line">                        str += <span class="string">"&lt;li&gt;&lt;a href='"</span>+ data_url +<span class="string">"' class='search-result-title'&gt;"</span>+ data_title +<span class="string">"&lt;/a&gt;"</span>;</span><br><span class="line">                        <span class="keyword">var</span> content = data.content.trim().replace(<span class="regexp">/&lt;[^&gt;]+&gt;/g</span>,<span class="string">""</span>);</span><br><span class="line">                        <span class="keyword">if</span> (first_occur &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// cut out 100 characters</span></span><br><span class="line">                            <span class="keyword">var</span> start = first_occur - <span class="number">20</span>;</span><br><span class="line">                            <span class="keyword">var</span> end = first_occur + <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(start &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                                start = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(start == <span class="number">0</span>)&#123;</span><br><span class="line">                                end = <span class="number">100</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span>(end &gt; content.length)&#123;</span><br><span class="line">                                end = content.length;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">var</span> match_content = content.substr(start, end); </span><br><span class="line"></span><br><span class="line">                            <span class="comment">// highlight all keywords</span></span><br><span class="line">                            keywords.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">keyword</span>)</span>&#123;</span><br><span class="line">                                <span class="keyword">var</span> regS = <span class="keyword">new</span> <span class="built_in">RegExp</span>(keyword, <span class="string">"gi"</span>);</span><br><span class="line">                                match_content = match_content.replace(regS, <span class="string">"&lt;em class=\"search-keyword\"&gt;"</span>+keyword+<span class="string">"&lt;/em&gt;"</span>);</span><br><span class="line">                            &#125;);</span><br><span class="line">                            </span><br><span class="line">                            str += <span class="string">"&lt;p class=\"search-result\"&gt;"</span> + match_content +<span class="string">"...&lt;/p&gt;"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        str += <span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                str += <span class="string">"&lt;/ul&gt;"</span>;</span><br><span class="line">                $resultContent.innerHTML = str;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>searchFunc 包含三个参数：</p><ul><li><strong>path</strong> - 用 hexo-generator-search 生成的搜索索引文件的路径。注意这个 <code>path</code> 和前面 hexo-generator-search 的 <code>path</code> 选项有所不同。这里的 path 才是指这个文件的路径，而前面的 <code>path</code> 指的是生成的文件名（也许第二个 <code>path</code> 叫 <code>filename</code> 更合适）；</li><li><strong>search_id</strong> - 搜索框的 id 。对于我们的例子，就是 <code>local-search-input</code>;</li><li><strong>content_id</strong> - 结果框的 id 。对于我们的例子，就是 <code>local-search-result</code>。</li></ul><h2 id="4-调用搜索函数"><a href="#4-调用搜索函数" class="headerlink" title="4. 调用搜索函数"></a>4. 调用搜索函数</h2><p>有了上面的检索函数，接下来可以在适当时机调用它。由于 path 的实际地址是根 <code>_config.yml</code> 里 <code>config.root</code> + <code>config.search.path</code> 两个值组成，所以我们最好将这个调用写在页面模板中，以方便获取站点的设置信息。例如，对于 ejs 模板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;      </span><br><span class="line">     <span class="keyword">var</span> search_path = <span class="string">"&lt;%= config.search.path %&gt;"</span>;</span><br><span class="line">     <span class="keyword">if</span> (search_path.length == <span class="number">0</span>) &#123;</span><br><span class="line">     search_path = <span class="string">"search.xml"</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">var</span> path = <span class="string">"&lt;%= config.root %&gt;"</span> + search_path;</span><br><span class="line">     searchFunc(path, <span class="string">'local-search-input'</span>, <span class="string">'local-search-result'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>至此就完成了本地检索引擎的实线，最后的工作就是修改样式，让检索页面更美观。在 searchFunc 函数中，我已经为几个关键的页面元素设定了 css 名：</p><ul><li>ul.search-result-list - 搜索结果列表的样式名；</li><li>a.search-result-title - 搜索结果文章标题的样式名；</li><li>p.search-result - 搜索结果每篇文章的预览段落的样式名；</li><li>em.search-keyword - 搜索结果每篇文章的预览段落中匹配关键词的样式名。</li></ul><p>最后给出 <a href="http://wzpan.github.io/hexo-theme-freemind/" target="_blank" rel="noopener">hexo-theme-freemind</a> 主题的相关样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.search-result-list</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.search-result-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.search-result</span> &#123;</span><br><span class="line">  color=#555;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">em</span><span class="selector-class">.search-keyword</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> dashed <span class="number">#4088b8</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 关于本站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何从倦怠的JVM中跳出来并拥抱上了前端框架</title>
      <link href="2020/10/2020-10-04-%E5%A6%82%E4%BD%95%E4%BB%8E%E5%80%A6%E6%80%A0%E7%9A%84JVM%E4%B8%AD%E8%B7%B3%E5%87%BA%E6%9D%A5%E5%B9%B6%E6%8B%A5%E6%8A%B1%E4%B8%8A%E4%BA%86%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
      <url>2020/10/2020-10-04-%E5%A6%82%E4%BD%95%E4%BB%8E%E5%80%A6%E6%80%A0%E7%9A%84JVM%E4%B8%AD%E8%B7%B3%E5%87%BA%E6%9D%A5%E5%B9%B6%E6%8B%A5%E6%8A%B1%E4%B8%8A%E4%BA%86%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​    说是引言，但其实已是全部。</p><p>​    这两天花了不多不少的时间把Vue系统地学习了一遍，之前用到Vue的地方还不少，不懂的地方就百度一下，其它的也凭着之前的感觉与经验慢慢地磨了下来，用的大多都是github上down下来的框架，这里添两行，那里去一下，一个run，跑得起来自然最好。当时看到那些花里胡哨的功能都实现了，心里不免沾沾自喜，其实我心里也知道，压根就没懂这个东西。但之前我心里想，我作为后端的开发，能实现这个功能就可以了！总不至于让我写前端的内容吧，这个想法一直伴随着我到几天之前…</p><p>​    就好像一部电影，你不去仔细看看，你对它的评价就会显得不那么公正，至少我是说服不了我自己。</p><p>​    是什么原因驱使着我打开了Vue的官网？是学习的欲望还是对金钱的渴望，我想两者皆有。那天其实是在看JVM的GC内容，作为一个Java开发人员，时刻保持学习底层知识，这个是很合理的！<code>点个赞</code>但的确是看的乏了，有种不可名状的抵触感，这便点了右上角的X 。其实想学习Vue也并不是心血来潮，因为我一直抱着可以但没必要的态度对待前端类的内容，所以就一直很菜，希望不会一直菜下去</p><p><img src="https://gitee.com/fagefocus/images/raw/mdPicture//xiaoxin_19.png" alt=""></p><p>​    接下来谈谈学完之后的感受吧！</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile</title>
      <link href="2020/09/volatile/"/>
      <url>2020/09/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引言-初露头角"><a href="#1-引言-初露头角" class="headerlink" title="1.引言-初露头角"></a>1.引言-初露头角</h1><p>​    其实刚开始接触Java时，看到<code>volatile</code>关键字时就不由得头大，当时点进去相关的博文，基本一上来就点题，即<code>保证内存可见性，防止指令重排序</code>，我当时就一菜鸟，每个字能看懂，合在一块就成天书了。当然了，现在来看这句话，的确是简明扼要的点中了<code>JDK5</code>增强以后的<code>volatile</code>所要表示的含义！话不多说，我们一起来看看<code>volatile</code>的秘密吧！</p><p>​    数学题中，一个题目越短，基本上这个题目就越难（别杠啊！打比方而已），为什么？题目越短，你能获取的信息就越少；同样，在Java中，像<code>volatile</code>、<code>synchronized</code>等，仅靠一个关键字就能保证多线程下的安全性，我们想要了解它，就必须向下深挖。所以在深入volatile之前，我们来谈谈几个重要的知识，<code>Java 的内存模型（JMM）</code>、<code>重排序</code>以及<code>happens-before规则</code>。</p><blockquote><p>Tips:因为涉及到底层的知识较多，博文篇幅可能较长。为了方便阅读，我会把相应的知识点单独成篇，在本篇里对相应技术点进行精简，只做结论性介绍。想要了解更多对应知识点，进入对应专栏阅读即可！</p></blockquote><h1 id="2-JMM"><a href="#2-JMM" class="headerlink" title="2.JMM"></a>2.JMM</h1><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解开发手册</title>
      <link href="2020/09/Spring-Annoatation/"/>
      <url>2020/09/Spring-Annoatation/</url>
      
        <content type="html"><![CDATA[<h1 id="1-组件注册"><a href="#1-组件注册" class="headerlink" title="1.组件注册"></a>1.组件注册</h1><h2 id="1-1-包扫描-ComponentScan-组件标注注解-Component、-Service、-Controller、-Repository-gt-自定义类"><a href="#1-1-包扫描-ComponentScan-组件标注注解-Component、-Service、-Controller、-Repository-gt-自定义类" class="headerlink" title="1.1 包扫描@ComponentScan+组件标注注解@Component、@Service、@Controller、@Repository-&gt;自定义类"></a>1.1 包扫描<code>@ComponentScan</code>+组件标注注解<code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code>-&gt;自定义类</h2><ul><li><code>@ComponentScan  value</code>:指定要扫描的包，默认为注解所在包及其子包<ul><li><code>excludeFilters = Filter[]</code>：指定扫描的时候按照什么规则排除哪些组件</li><li><code>includeFilters = Filter[]</code> ：指定扫描的时候只需要包含哪些组件，需将<code>useDefaultFilters</code>置false<ul><li><code>FilterType.ANNOTATION</code>：按照注解</li><li><code>FilterType.ASSIGNABLE_TYPE</code>：按照给定的类型</li><li><code>FilterType.ASPECTJ</code>：使用ASPECTJ表达式</li><li><code>FilterType.REGEX</code>：使用正则指定</li><li><code>FilterType.CUSTOM</code>：使用自定义规则(实现<code>TypeFilter</code>)</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScans</span>(</span><br><span class="line">value = &#123;</span><br><span class="line"><span class="meta">@ComponentScan</span>(value=<span class="string">"com.onechat"</span>,includeFilters = &#123;</span><br><span class="line">                    <span class="meta">@Filter</span>(type=FilterType.ANNOTATION,classes=&#123;Controller<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                    @<span class="title">Filter</span>(<span class="title">type</span></span>=FilterType.ASSIGNABLE_TYPE,classes=&#123;BookService<span class="class">.<span class="keyword">class</span>&#125;),</span></span><br><span class="line"><span class="class">                    @<span class="title">Filter</span>(<span class="title">type</span></span>=FilterType.CUSTOM,classes=&#123;MyTypeFilter<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">&#125;,<span class="title">useDefaultFilters</span> </span>= <span class="keyword">false</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * metadataReader：读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment"> * metadataReaderFactory:可以获取到其他任何类信息的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//获取当前类注解的信息</span></span><br><span class="line">AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();</span><br><span class="line"><span class="comment">//获取当前正在扫描的类的类信息</span></span><br><span class="line">ClassMetadata classMetadata = metadataReader.getClassMetadata();</span><br><span class="line"><span class="comment">//获取当前类资源（类的路径）</span></span><br><span class="line">Resource resource = metadataReader.getResource();</span><br><span class="line"></span><br><span class="line">String className = classMetadata.getClassName();</span><br><span class="line">System.out.println(<span class="string">"---&gt;"</span>+className);</span><br><span class="line"><span class="keyword">if</span>(className.contains(<span class="string">"er"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-Bean"><a href="#1-2-Bean" class="headerlink" title="1.2@Bean"></a>1.2<code>@Bean</code></h2><p>定义：给容器中注册一个Bean;类型为返回值的类型，id默认是用方法名作为id</p><p>用途：主要用于导入的第三方包里面的组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"hanmeimei"</span>, <span class="number">14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-1-Conditional-Condition"><a href="#1-2-1-Conditional-Condition" class="headerlink" title="1.2.1 @Conditional({Condition})"></a>1.2.1 <code>@Conditional({Condition})</code></h3><p>定义:按照一定的条件判断，满足条件给容器中注册bean；也可以定义在类上，在类中组件统一设置，表示满足当前条件，这个类中配置的所有bean注册才能生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional</span>(LinuxCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">@Bean("linus")</span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="string">"linus"</span>, <span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否linux系统</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConditionContext：判断条件能使用的上下文（环境）</span></span><br><span class="line"><span class="comment"> * AnnotatedTypeMetadata：注释信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO是否linux系统</span></span><br><span class="line"><span class="comment">//1、能获取到ioc使用的beanfactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();</span><br><span class="line"><span class="comment">//2、获取类加载器</span></span><br><span class="line">ClassLoader classLoader = context.getClassLoader();</span><br><span class="line"><span class="comment">//3、获取当前环境信息</span></span><br><span class="line">Environment environment = context.getEnvironment();</span><br><span class="line"><span class="comment">//4、获取到bean定义的注册类</span></span><br><span class="line">BeanDefinitionRegistry registry = context.getRegistry();</span><br><span class="line">String property = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line"><span class="comment">//可以判断容器中的bean注册情况，也可以给容器中注册bean</span></span><br><span class="line"><span class="keyword">boolean</span> definition = registry.containsBeanDefinition(<span class="string">"person"</span>);</span><br><span class="line"><span class="keyword">if</span>(property.contains(<span class="string">"linux"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////类中组件统一设置。满足当前条件，这个类中配置的所有bean注册才能生效；</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;LinuxCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-Scope"><a href="#1-2-2-Scope" class="headerlink" title="1.2.2 @Scope"></a>1.2.2 <code>@Scope</code></h3><blockquote><p>调整作用域</p></blockquote><ul><li>prototype：多实例的，ioc容器启动并不会去调用方法创建对象放在容器中，每次获取的时候才会调用方法创建对象</li><li>singleton：单实例的（默认值），ioc容器启动会调用方法创建对象放到ioc容器中，以后每次获取就是直接从容器中拿</li></ul><h3 id="1-2-3-Lazy"><a href="#1-2-3-Lazy" class="headerlink" title="1.2.3 @Lazy"></a>1.2.3 <code>@Lazy</code></h3><blockquote><p>懒加载:对于单实例bean来说，默认在容器启动的时候创建对象，使用<code>@Lazy</code>后，容器启动不创建对象。第一次使用(获取)Bean创建对象，并初始化</p></blockquote><h2 id="1-3-Import"><a href="#1-3-Import" class="headerlink" title="1.3 @Import"></a>1.3 <code>@Import</code></h2><p>作用：快速给容器中导入一个组件</p><h3 id="1-3-1-Import-类名"><a href="#1-3-1-Import-类名" class="headerlink" title="1.3.1 Import(类名)"></a>1.3.1 <code>Import(类名)</code></h3><blockquote><p>导入组件，id默认是组件的全类名</p></blockquote><h3 id="1-3-2-ImportSelector"><a href="#1-3-2-ImportSelector" class="headerlink" title="1.3.2 ImportSelector"></a>1.3.2 <code>ImportSelector</code></h3><blockquote><p>实现<code>ImportSelector</code>接口，自定义逻辑返回需要导入的组件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义逻辑返回需要导入的组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值:就是到导入到容器中的组件全类名</span></span><br><span class="line"><span class="comment">//AnnotationMetadata:当前---标注@Import注解的类---的所有注解信息</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//importingClassMetadata</span></span><br><span class="line"><span class="comment">//方法不要返回null值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.onechat.bean.Blue"</span>,<span class="string">"com.onechat.bean.Yellow"</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-3-ImportBeanDefinitionRegister"><a href="#1-3-3-ImportBeanDefinitionRegister" class="headerlink" title="1.3.3 ImportBeanDefinitionRegister"></a>1.3.3 <code>ImportBeanDefinitionRegister</code></h3><blockquote><p>实现<code>ImportBeanDefinitionRegistrar</code>接口，手动注册Bean，可以加入逻辑，判断是否满足条件注册</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AnnotationMetadata：当前类的注解信息</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry:BeanDefinition注册类；</span></span><br><span class="line"><span class="comment"> * 把所有需要添加到容器中的bean；调用</span></span><br><span class="line"><span class="comment"> * BeanDefinitionRegistry.registerBeanDefinition手工注册进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> definition = registry.containsBeanDefinition(<span class="string">"com.onechat.bean.Red"</span>);</span><br><span class="line"><span class="keyword">boolean</span> definition2 = registry.containsBeanDefinition(<span class="string">"com.onechat.bean.Blue"</span>);</span><br><span class="line"><span class="keyword">if</span>(definition &amp;&amp; definition2)&#123;</span><br><span class="line"><span class="comment">//指定Bean定义信息；（Bean的类型，Bean。。。）</span></span><br><span class="line">RootBeanDefinition beanDefinition = <span class="keyword">new</span> RootBeanDefinition(RainBow<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//注册一个Bean，指定bean名</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"rainBow"</span>, beanDefinition);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-Spring定义的FactoryBean"><a href="#1-4-Spring定义的FactoryBean" class="headerlink" title="1.4 Spring定义的FactoryBean"></a>1.4 Spring定义的<code>FactoryBean</code></h2><h3 id="1-4-1-默认获取到的是工厂bean调用getObject创建的对象"><a href="#1-4-1-默认获取到的是工厂bean调用getObject创建的对象" class="headerlink" title="1.4.1 默认获取到的是工厂bean调用getObject创建的对象"></a>1.4.1 默认获取到的是工厂bean调用<code>getObject</code>创建的对象</h3><h3 id="1-4-2-在id前面加个-amp-标识即能获取到FactoryBean自身"><a href="#1-4-2-在id前面加个-amp-标识即能获取到FactoryBean自身" class="headerlink" title="1.4.2 在id前面加个&amp;标识即能获取到FactoryBean自身"></a>1.4.2 在id前面加个<code>&amp;</code>标识即能获取到FactoryBean自身</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Spring定义的FactoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Color</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//返回一个Color对象，这个对象会添加到容器中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Color <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"ColorFactoryBean...getObject..."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Color();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> Color<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//是单例？</span></span><br><span class="line"><span class="comment">//true：这个bean是单实例，在容器中保存一份</span></span><br><span class="line"><span class="comment">//false：多实例，每次获取都会创建一个新的bean；</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2.生命周期"></a>2.生命周期</h1><p>bean的生命周期：bean创建—初始化—-销毁的过程</p><p>构造（对象创建）：</p><ul><li><p>单实例：在容器启动的时候创建对象</p></li><li><p>多实例：在每次获取的时候创建对象</p></li></ul><h2 id="2-1-容器管理bean的生命周期"><a href="#2-1-容器管理bean的生命周期" class="headerlink" title="2.1 容器管理bean的生命周期"></a>2.1 容器管理bean的生命周期</h2><p>​    我们可以自定义初始化和销毁方法；容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法</p><h3 id="2-1-1-指定初始化init-method和销毁方法destroy-method"><a href="#2-1-1-指定初始化init-method和销毁方法destroy-method" class="headerlink" title="2.1.1 指定初始化init-method和销毁方法destroy-method"></a>2.1.1 指定初始化<code>init-method</code>和销毁方法<code>destroy-method</code></h3><p>通过<code>@Bean</code>指定<code>init-method</code>和<code>destroy-method</code>，类似于在xml文件中配置&lt;bean id=”” class=”” `nit-method=”” destroy-method=””/&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>,destroyMethod=<span class="string">"detory"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Car <span class="title">car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"car constructor..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"car ... init..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detory</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"car ... detory..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-2-通过让Bean实现InitializingBean和DisposableBean"><a href="#2-1-2-通过让Bean实现InitializingBean和DisposableBean" class="headerlink" title="2.1.2 通过让Bean实现InitializingBean和DisposableBean"></a>2.1.2 通过让Bean实现<code>InitializingBean</code>和<code>DisposableBean</code></h3><p><code>InitializingBean</code>:定义初始化逻辑</p><p><code>DisposableBean</code>:定义销毁逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cat constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"cat...destroy..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"cat...afterPropertiesSet..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-3-使用JSR250中-PostConstruct和-PreDestroy"><a href="#2-1-3-使用JSR250中-PostConstruct和-PreDestroy" class="headerlink" title="2.1.3 使用JSR250中@PostConstruct和@PreDestroy"></a>2.1.3 使用<code>JSR250</code>中<code>@PostConstruct</code>和<code>@PreDestroy</code></h3><p><code>@PostConstruct</code>：在bean创建完成并且属性赋值完成；来执行初始化方法</p><p><code>@PreDestroy</code>：在容器销毁bean之前通知我们进行清理工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog constructor..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对象创建并赋值之后调用</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog....@PostConstruct..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//容器移除对象之前</span></span><br><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detory</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog....@PreDestroy..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-实现BeanPostProcessor"><a href="#2-1-4-实现BeanPostProcessor" class="headerlink" title="2.1.4 实现BeanPostProcessor"></a>2.1.4 实现<code>BeanPostProcessor</code></h3><p><code>BeanPostProcessor</code>[interface]：bean的后置处理器，在bean初始化前后进行一些处理工作</p><ul><li><p><code>postProcessBeforeInitialization</code>:在初始化之前工作</p></li><li><p><code>postProcessAfterInitialization</code>:在初始化之后工作</p></li></ul><p><img src="https://gitee.com/fagefocus/images/raw/mdPicture//image-20200903121138908.png" alt="image-20200903121138908"></p><p>从图中可以看到，Spring底层对BeanPostProcess接口有大量使用：</p><ul><li><p>bean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async,都是由xxx BeanPostProcessor来完成，例如：</p><ul><li><p><code>InitDestroyAnnotationBeanPostProcessor</code>会对<code>@PostConstructor</code>和<code>@PreDestroy</code>注解进行解析来达到容器的初始化和销毁方法的执行</p></li><li><p><code>ApplicationContextAwareProcessor</code>会在实现了<code>ApplicationContextAware</code>接口的bean里面</p><p>通过<code>((ApplicationContextAware) bean).setApplicationContext(this.applicationContext)</code>将容器注入到bean中</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 后置处理器：初始化前后进行处理工作</span></span><br><span class="line"><span class="comment"> * 将后置处理器加入到容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"postProcessBeforeInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"postProcessAfterInitialization..."</span>+beanName+<span class="string">"=&gt;"</span>+bean);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">遍历得到容器中所有的BeanPostProcessor；挨个执行beforeInitialization，一但返回null，跳出for循环，不会执行后面的  BeanPostProcessor.postProcessorsBeforeInitialization.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     BeanPostProcessor原理</span></span><br><span class="line"><span class="comment">     populateBean(beanName, mbd, instanceWrapper);给bean进行属性赋值</span></span><br><span class="line"><span class="comment">     initializeBean</span></span><br><span class="line"><span class="comment">     &#123;</span></span><br><span class="line"><span class="comment">         applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span></span><br><span class="line"><span class="comment">         invokeInitMethods(beanName, wrappedBean, mbd);执行自定义初始化</span></span><br><span class="line"><span class="comment">         applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020/08/23/JMM之Happens-before Order</title>
      <link href="2020/08/23/JMM%E4%B9%8BHappens-before%20Order/"/>
      <url>2020/08/23/JMM%E4%B9%8BHappens-before%20Order/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM之Happens-before-Order"><a href="#JMM之Happens-before-Order" class="headerlink" title="JMM之Happens-before Order"></a>JMM之<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5" target="_blank" rel="noopener">Happens-before Order</a></h1><h2 id="1-内存可见性发生原因？"><a href="#1-内存可见性发生原因？" class="headerlink" title="1.内存可见性发生原因？"></a>1.内存可见性发生原因？</h2><blockquote><p>电脑多CPU并且都有缓存导致</p></blockquote><h2 id="2-关于-happens-before-有以下8条规则？"><a href="#2-关于-happens-before-有以下8条规则？" class="headerlink" title="2.关于 happens-before,有以下8条规则？"></a>2.关于 happens-before,有以下8条规则？</h2><table><thead><tr><th>原则</th><th></th></tr></thead><tbody><tr><td>单线程Happens-Before原则</td><td>在同一个线程中，书写在前面的操作happen-before后面的操作</td></tr><tr><td>锁的Happens-Before原则</td><td>同一个锁的unlock操作happen-before此锁的lock操作</td></tr><tr><td>volatile的Happens-Before原则</td><td>对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)</td></tr><tr><td>Happens-Before的传递性原则</td><td>如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作</td></tr><tr><td>线程启动的Happens-Before原则</td><td>同一个线程的start方法happen-before此线程的其它方法</td></tr><tr><td>线程中断的Happens-Before原则</td><td>对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码</td></tr><tr><td>线程终结的Happens-Before原则</td><td>线程中的所有操作都happen-before线程的终止检测</td></tr><tr><td>对象创建的Happens-Before原则</td><td>一个对象的初始化完成先于他的finalize方法调用</td></tr></tbody></table><p>—————————————————-<a href="https://segmentfault.com/a/1190000011458941" target="_blank" rel="noopener">详情请见</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020/06/06/jvm_manual</title>
      <link href="2020/06/06/jvm_manual/"/>
      <url>2020/06/06/jvm_manual/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_45759791/article/details/107322503" target="_blank" rel="noopener">第一章、JVM和Java体系架构</a></p><p><a href="https://blog.csdn.net/weixin_45759791/article/details/107322692" target="_blank" rel="noopener">第二章、类加载子系统</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020/06/06/vue-manual</title>
      <link href="2020/06/06/vue-manual/"/>
      <url>2020/06/06/vue-manual/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020/06/06/java8</title>
      <link href="2020/06/06/java8/"/>
      <url>2020/06/06/java8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-函数式编程"><a href="#1-函数式编程" class="headerlink" title="1.函数式编程"></a>1.函数式编程</h1><h2 id="1-1-Lambda基础"><a href="#1-1-Lambda基础" class="headerlink" title="1.1 Lambda基础"></a>1.1 Lambda基础</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020/06/06/java-manual</title>
      <link href="2020/06/06/java-manual/"/>
      <url>2020/06/06/java-manual/</url>
      
        <content type="html"><![CDATA[<h1 id="1-反射"><a href="#1-反射" class="headerlink" title="1.反射"></a>1.反射</h1><h2 id="1-类封装与反射"><a href="#1-类封装与反射" class="headerlink" title="1.*类封装与反射"></a>1.*类封装与反射</h2><table><thead><tr><th>类封装</th><th>反射</th></tr></thead><tbody><tr><td>正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段</td><td>一种非常规的用法,会破坏对象的封装，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值</td></tr><tr><td></td><td><code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全</td></tr></tbody></table><p>除byte,char,short,int ,long,float.double.boolean这些基本数据类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>），如String，String[],Exception等。同时JVM为每一种基本类型，如int，也创建了<code>Class</code>，通过<code>int.class</code>访问(<em>其clazz.isPrimitive()的返回结果为true</em>)</p><h2 id="1-1-Class"><a href="#1-1-Class" class="headerlink" title="1.1 Class"></a>1.1 Class</h2><h3 id="1-1-1-如何获取一个class的Class实例？"><a href="#1-1-1-如何获取一个class的Class实例？" class="headerlink" title="1.1.1 如何获取一个class的Class实例？"></a>1.1.1 如何获取一个class的Class实例？</h3><table><thead><tr><th>1.通过一个<code>class</code>的静态变量<code>class</code>获取</th><th>Class cls = String.class;</th></tr></thead><tbody><tr><td>2.通过该实例变量提供的<code>getClass()</code>方法获取^前提:存在一个实例变量^</td><td>String s = “Hello”; Class cls = s.getClass();</td></tr><tr><td>3.通过静态方法<code>Class.forName()</code>获取^前提:知道一个<code>class</code>的完整类名^</td><td>Class cls = Class.forName(“java.lang.String”);</td></tr></tbody></table><p>三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型</p><h3 id="1-1-2-Class实例比较和instanceof的区别"><a href="#1-1-2-Class实例比较和instanceof的区别" class="headerlink" title="1.1.2 Class实例比较和instanceof的区别"></a>1.1.2 <code>Class</code>实例比较和<code>instanceof</code>的区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> b1 = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true </span></span><br><span class="line"><span class="keyword">boolean</span> b2 = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b3 = n.getClass() == Integer<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b4 = n.getClass() == Number<span class="class">.<span class="keyword">class</span></span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th><code>instanceof</code></th><th><code>Class</code>实例比较</th></tr></thead><tbody><tr><td>区别</td><td>不但匹配指定类型，还匹配指定类型的子类</td><td>用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较</td></tr></tbody></table><p>​        <strong>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例</strong></p><h3 id="1-1-3-创建实例-newInstance"><a href="#1-1-3-创建实例-newInstance" class="headerlink" title="1.1.3 创建实例 newInstance()"></a>1.1.3 创建实例 <code>newInstance()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Class.newInstance()可以创建类实例，它的局限是：只能调用public的无参数构造方法。带参数的构造方法，或者非public的构造方法都无法通过Class.newInstance()被调用。</span></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">String s = (String) cls.newInstance();</span><br></pre></td></tr></table></figure><h3 id="1-1-4-动态加载"><a href="#1-1-4-动态加载" class="headerlink" title="1.1.4 动态加载"></a>1.1.4 动态加载</h3><blockquote><p>VM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载</p><p>利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commons Logging优先使用Log4j,大致实现思路</span></span><br><span class="line">LogFactory factory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (isClassPresent(<span class="string">"org.apache.logging.log4j.Logger"</span>)) &#123;</span><br><span class="line">    factory = createLog4j();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory = createJdkLog();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isClassPresent</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class.forName(name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因</span></span><br></pre></td></tr></table></figure><h2 id="1-2-访问字段"><a href="#1-2-访问字段" class="headerlink" title="1.2 访问字段"></a>1.2 访问字段</h2><h3 id="1-2-1-通过Class实例获取字段信息"><a href="#1-2-1-通过Class实例获取字段信息" class="headerlink" title="1.2.1 通过Class实例获取字段信息"></a>1.2.1 通过<code>Class</code>实例获取字段信息</h3><table><thead><tr><th>Field getField(name)</th><th>根据字段名获取某个public的field（包括父类）</th></tr></thead><tbody><tr><td>Field getDeclaredField(name)</td><td>根据字段名获取当前类的某个field（不包括父类）<del>private也可获取</del></td></tr><tr><td>Field[] getFields()</td><td>获取所有public的field（包括父类）</td></tr><tr><td>Field[] getDeclaredFields()</td><td>获取当前类的所有field（不包括父类）</td></tr></tbody></table><h3 id="1-2-2-Field对象包含了一个字段的所有信息"><a href="#1-2-2-Field对象包含了一个字段的所有信息" class="headerlink" title="1.2.2  Field对象包含了一个字段的所有信息"></a>1.2.2  <code>Field</code>对象包含了一个字段的所有信息</h3><table><thead><tr><th>getName()</th><th>返回字段名称，例如，<code>&quot;name&quot;</code></th></tr></thead><tbody><tr><td>getType()</td><td>返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code></td></tr><tr><td>getModifiers()</td><td>返回字段的修饰符<del>它是一个<code>int</code>，不同的bit表示不同的含义</del></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String类的value字段</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取字段信息</span></span><br><span class="line">Field f = String.class.getDeclaredField("value");</span><br><span class="line">f.getName(); <span class="comment">// "value"</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="1-2-3-获取字段值-Field-get-Object"><a href="#1-2-3-获取字段值-Field-get-Object" class="headerlink" title="1.2.3 获取字段值 Field.get(Object)"></a>1.2.3 获取字段值 <code>Field.get(Object)</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">//对于私有字段，需要setAccessible(true)</span></span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-4-设置字段值Field-set-Object-Object"><a href="#1-2-4-设置字段值Field-set-Object-Object" class="headerlink" title="1.2.4 设置字段值Field.set(Object, Object)"></a>1.2.4 设置字段值<code>Field.set(Object, Object)</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个Object参数是指定的实例，第二个Object参数是待修改的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        f.set(p, <span class="string">"Xiao Hong"</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Hong"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-调用方法"><a href="#1-3-调用方法" class="headerlink" title="1.3 调用方法"></a>1.3 调用方法</h2><h3 id="1-3-1-获取Method信息"><a href="#1-3-1-获取Method信息" class="headerlink" title="1.3.1 获取Method信息"></a>1.3.1 获取<code>Method</code>信息</h3><table><thead><tr><th>Method getMethod(name, Class…)</th><th>获取某个<code>public</code>的<code>Method</code>（包括父类）</th></tr></thead><tbody><tr><td>Method getDeclaredMethod(name, Class…)</td><td>获取当前类的某个<code>Method</code>（不包括父类）</td></tr><tr><td>Method[] getMethods()</td><td>获取所有<code>public</code>的<code>Method</code>（包括父类）</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>获取当前类的所有<code>Method</code>（不包括父类）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getScore"</span>, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getName"</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">"getGrade"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">//public int Student.getScore(java.lang.String)</span></span><br><span class="line"><span class="comment">//public java.lang.String Person.getName()</span></span><br><span class="line"><span class="comment">//private int Student.getGrade(int)</span></span><br></pre></td></tr></table></figure><h3 id="1-3-2-Method对象包含一个方法的所有信息"><a href="#1-3-2-Method对象包含一个方法的所有信息" class="headerlink" title="1.3.2 Method对象包含一个方法的所有信息"></a>1.3.2 <code>Method</code>对象包含一个方法的所有信息</h3><table><thead><tr><th>getName()</th><th>返回方法名称，例如：<code>&quot;getScore&quot;</code></th></tr></thead><tbody><tr><td>getReturnType()</td><td>返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code></td></tr><tr><td>getParameterTypes()</td><td>返回方法的参数类型，是一个Class数组，例如：<code>{String.class, int.class}</code></td></tr><tr><td>getModifiers()</td><td>返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义</td></tr></tbody></table><h3 id="1-3-3-方法调用"><a href="#1-3-3-方法调用" class="headerlink" title="1.3.3 方法调用"></a>1.3.3 方法调用</h3><h4 id="1-3-3-1-调用一般方法-invoke-实例对象，方法参数"><a href="#1-3-3-1-调用一般方法-invoke-实例对象，方法参数" class="headerlink" title="1.3.3.1 调用一般方法[invoke(实例对象，方法参数)]"></a>1.3.3.1 调用一般方法[<code>invoke(实例对象，方法参数)</code>]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反射来调用substring方法</span></span><br><span class="line"><span class="comment">//单个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">"Hello world"</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod("substring", int.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//多个参数之间用,隔开</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// String对象:</span></span><br><span class="line">        String s = <span class="string">"Hello world"</span>;</span><br><span class="line">        <span class="comment">// 获取String substring(int)方法，参数为int:</span></span><br><span class="line">        Method m = String.class.getMethod("substring", int.class, int.class);</span><br><span class="line">        <span class="comment">// 在s对象上调用该方法并获取结果:</span></span><br><span class="line">        String r = (String) m.invoke(s, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错</span></span><br></pre></td></tr></table></figure><h4 id="1-3-3-2-调用静态方法-invoke-null，方法参数"><a href="#1-3-3-2-调用静态方法-invoke-null，方法参数" class="headerlink" title="1.3.3.2 调用静态方法[invoke(null，方法参数)]"></a>1.3.3.2 调用静态方法[<code>invoke(null，方法参数)</code>]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null</span></span><br><span class="line"><span class="comment">//调用Integer.parseInt(String)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Integer.parseInt(String)方法，参数为String:</span></span><br><span class="line">        Method m = Integer.class.getMethod("parseInt", String.class);</span><br><span class="line">        <span class="comment">// 调用该静态方法并获取结果:</span></span><br><span class="line">        Integer n = (Integer) m.invoke(<span class="keyword">null</span>, <span class="string">"12345"</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-3-调用非public方法-Method-setAccessible-true"><a href="#1-3-3-3-调用非public方法-Method-setAccessible-true" class="headerlink" title="1.3.3.3 调用非public方法[Method.setAccessible(true)]"></a>1.3.3.3 调用非<code>public</code>方法[<code>Method.setAccessible(true)</code>]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和Field类似，对于非public方法，我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Method m = p.getClass().getDeclaredMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        m.invoke(p, <span class="string">"Bob"</span>);</span><br><span class="line">        System.out.println(p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全</span></span><br></pre></td></tr></table></figure><h3 id="1-3-4-多态-遵循多态原则"><a href="#1-3-4-多态-遵循多态原则" class="headerlink" title="1.3.4 多态[遵循多态原则]"></a>1.3.4 多态[遵循多态原则]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取Person的hello方法:</span></span><br><span class="line">        Method h = Person.class.getMethod("hello");</span><br><span class="line">        <span class="comment">// 对Student实例调用hello方法:</span></span><br><span class="line">        h.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student:hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">//Student:hello </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）</span></span><br><span class="line">Method m = Person.class.getMethod("hello");</span><br><span class="line">m.invoke(<span class="keyword">new</span> Student());</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.hello();</span><br></pre></td></tr></table></figure><h2 id="1-4-调用构造方法"><a href="#1-4-调用构造方法" class="headerlink" title="1.4 调用构造方法"></a>1.4 调用构造方法</h2><h3 id="1-4-1-获取Constructor对象"><a href="#1-4-1-获取Constructor对象" class="headerlink" title="1.4.1 获取Constructor对象"></a>1.4.1 获取<code>Constructor</code>对象</h3><table><thead><tr><th>getConstructor(Class…)</th><th>获取某个<code>public</code>的<code>Constructor</code></th></tr></thead><tbody><tr><td>getDeclaredConstructor(Class…)</td><td>获取某个<code>Constructor</code></td></tr><tr><td>getConstructors()</td><td>获取所有<code>public</code>的<code>Constructor</code></td></tr><tr><td>getDeclaredConstructors()</td><td>获取所有<code>Constructor</code></td></tr></tbody></table><h3 id="1-4-2-创建实例对象newInstance"><a href="#1-4-2-创建实例对象newInstance" class="headerlink" title="1.4.2 创建实例对象newInstance()"></a>1.4.2 创建实例对象<code>newInstance()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取构造方法Integer(int):</span></span><br><span class="line">        Constructor cons1 = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 调用构造方法:</span></span><br><span class="line">        Integer n1 = (Integer) cons1.newInstance(<span class="number">123</span>);</span><br><span class="line">        System.out.println(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取构造方法Integer(String)</span></span><br><span class="line">        Constructor cons2 = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getConstructor</span>(<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Integer n2 = (Integer) cons2.newInstance(<span class="string">"456"</span>);</span><br><span class="line">        System.out.println(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//即便不获取Constructor对象,直接通过xxx.class.newInstance()也是可以的。但这样的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</span></span><br></pre></td></tr></table></figure><h3 id="1-4-3-调用非-public-的Constructor-Constructor-setAccessible-true"><a href="#1-4-3-调用非-public-的Constructor-Constructor-setAccessible-true" class="headerlink" title="1.4.3 调用非 public 的Constructor[Constructor.setAccessible(true)]"></a>1.4.3 调用非 <code>public</code> 的<code>Constructor</code>[<code>Constructor.setAccessible(true)</code>]</h3><blockquote><p><code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败</p></blockquote><h3 id="1-4-4-无多态问题"><a href="#1-4-4-无多态问题" class="headerlink" title="1.4.4 无多态问题"></a>1.4.4 无多态问题</h3><blockquote><p><code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题</p></blockquote><h2 id="1-5-获取继承关系"><a href="#1-5-获取继承关系" class="headerlink" title="1.5 获取继承关系"></a>1.5 获取继承关系</h2><h3 id="1-5-1-获取父类的Class-Class-getSuperclass"><a href="#1-5-1-获取父类的Class-Class-getSuperclass" class="headerlink" title="1.5.1 获取父类的Class[Class.getSuperclass()]"></a>1.5.1 获取父类的Class[<code>Class.getSuperclass()</code>]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer的父类类型是Number，Number的父类是Object，Object的父类是null。除Object外，其他任何非interface的Class都必定存在一个父类类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class i = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class n = i.getSuperclass();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        Class o = n.getSuperclass();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(o.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line">    <span class="comment">//class java.lang.Number </span></span><br><span class="line">    <span class="comment">//class java.lang.Object </span></span><br><span class="line">    <span class="comment">//null</span></span><br></pre></td></tr></table></figure><h3 id="1-5-2-获取interface-Class-getInterfaces"><a href="#1-5-2-获取interface-Class-getInterfaces" class="headerlink" title="1.5.2 获取interface[Class.getInterfaces()]"></a>1.5.2 获取interface[<code>Class.getInterfaces()</code>]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line">    <span class="comment">//interface java.lang.Comparable </span></span><br><span class="line">    <span class="comment">//interface java.lang.constant.Constable </span></span><br><span class="line">    <span class="comment">//interface java.lang.constant.ConstantDesc</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getInterfaces()只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class s = Integer<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>()</span>;</span><br><span class="line">        Class[] is = s.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class i : is) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果:</span></span><br><span class="line"><span class="comment">//interface java.io.Serializable </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Integer的父类是Number，Number实现的接口是java.io.Serializable</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*1.对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces()</span></span><br><span class="line"><span class="comment">*2.如果一个类没有实现任何interface，那么getInterfaces()返回空数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.println(java.io.DataInputStream<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>; </span><br><span class="line"><span class="comment">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class="line"></span><br><span class="line">System.out.println(java.io.Closeable<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>())</span>; </span><br><span class="line"><span class="comment">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure><h3 id="1-5-3-继承关系instanceof"><a href="#1-5-3-继承关系instanceof" class="headerlink" title="1.5.3 继承关系instanceof"></a>1.5.3 继承关系<code>instanceof</code></h3><table><thead><tr><th><code>instanceof</code></th><th>一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符</th></tr></thead><tbody><tr><td><code>isAssignableFrom()</code></td><td>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//instanceof</span></span><br><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//isAssignableFrom()</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line"><span class="comment">// Number n = ?</span></span><br><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line"><span class="comment">// Object o = ?</span></span><br><span class="line">Object<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line"><span class="comment">// Integer i = ?</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Number</span>.<span class="title">class</span>)</span>; <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h1 id="2-日期与时间"><a href="#2-日期与时间" class="headerlink" title="2.日期与时间"></a>2.日期与时间</h1><h1 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3.多线程"></a>3.多线程</h1><blockquote><p>进程和线程:一个<strong>进程</strong>可以包含一个或多个<strong>线程</strong>，但至少会有一个<strong>线程</strong>。即进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程</p></blockquote><blockquote><p>多进程缺点：</p><ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li><li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li></ul></blockquote><blockquote><p>多进程优点：</p><ul><li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</li></ul></blockquote><h2 id="3-1-创建新线程"><a href="#3-1-创建新线程" class="headerlink" title="3.1 创建新线程"></a>3.1 创建新线程</h2><blockquote><p>1.继承Thread类</p><p>2.实现Runnable接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda语法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"start new thread!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start(); <span class="comment">// 启动新线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-1-run-和start"><a href="#3-1-1-run-和start" class="headerlink" title="3.1.1 run()和start()"></a>3.1.1 <code>run()</code>和<code>start()</code></h3><blockquote><p>调用<code>Thread</code>实例的<code>start()</code>方法才是启动新线程</p><ul><li>查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的</li></ul></blockquote><blockquote><p>调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程</p></blockquote><h3 id="3-1-2-线程的优先级"><a href="#3-1-2-线程的优先级" class="headerlink" title="3.1.2 线程的优先级"></a>3.1.2 线程的优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设定优先级</span></span><br><span class="line"><span class="comment">//优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</span></span><br><span class="line">Thread.setPriority(<span class="keyword">int</span> n) <span class="comment">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure><p>==注意：当一个新的线程启动以后，它就由操作系统调度，程序本身无法确定线程的调度顺序==</p><h2 id="3-2-线程状态"><a href="#3-2-线程状态" class="headerlink" title="3.2  线程状态"></a>3.2  线程状态</h2><table><thead><tr><th align="center">状态</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center">New</td><td align="left">新创建的线程，尚未执行</td></tr><tr><td align="center">Runnable</td><td align="left">运行中的线程，正在执行<code>run()</code>方法的Java代码</td></tr><tr><td align="center">Blocked</td><td align="left">运行中的线程，因为某些操作被阻塞而挂起</td></tr><tr><td align="center">Waiting</td><td align="left">运行中的线程，因为某些操作在等待中</td></tr><tr><td align="center">Timed Waiting</td><td align="left">运行中的线程，因为执行<code>sleep()</code>方法正在计时等待</td></tr><tr><td align="center">Terminated</td><td align="left">线程已终止，因为<code>run()</code>方法执行完毕</td></tr></tbody></table><h3 id="3-2-1-线程中止原因"><a href="#3-2-1-线程中止原因" class="headerlink" title="3.2.1 线程中止原因"></a>3.2.1 线程中止原因</h3><table><thead><tr><th>线程正常终止</th><th><code>run()</code>方法执行到<code>return</code>语句返回</th></tr></thead><tbody><tr><td>线程意外终止</td><td><code>run()</code>方法因为未捕获的异常导致线程终止</td></tr><tr><td><del>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止</del></td><td>不推荐使用</td></tr></tbody></table><h3 id="3-2-2-join"><a href="#3-2-2-join" class="headerlink" title="3.2.2   join()"></a>3.2.2   <code>join()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        t.join();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">start</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>使用</th><th>解释</th></tr></thead><tbody><tr><td>join()</td><td>对另一个线程对象调用<code>join()</code>方法可以等待其执行结束</td></tr><tr><td>线程结束调用join()</td><td>对已经运行结束的线程调用<code>join()</code>方法会立刻返回</td></tr><tr><td>join(long)</td><td>指定等待时间，超过等待时间线程仍然没有结束就不再等待</td></tr></tbody></table><h2 id="3-3-中断线程interrupt"><a href="#3-3-中断线程interrupt" class="headerlink" title="3.3 中断线程interrupt()"></a>3.3 中断线程<code>interrupt()</code></h2><h1 id="4-注解"><a href="#4-注解" class="headerlink" title="4.注解"></a>4.注解</h1><h2 id="4-1-使用注解"><a href="#4-1-使用注解" class="headerlink" title="4.1 使用注解"></a>4.1 使用注解</h2><blockquote><p>注解<code>Annotation</code></p><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”</p></blockquote><table><thead><tr><th>注解分类</th><th>举例</th><th>举例</th><th>注意</th></tr></thead><tbody><tr><td>1.由编译器使用的注解</td><td><code>@Override</code>让编译器检查该方法是否正确地实现了覆写</td><td><code>@SuppressWarnings</code>告诉编译器忽略此处代码产生的警告</td><td>注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了</td></tr><tr><td>2.由工具处理<code>.class</code>文件使用的注解</td><td>有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能</td><td></td><td>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理</td></tr><tr><td>3.程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解</td><td>一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用</td><td></td><td>这是Java代码读取该注解实现的功能，JVM并不会识别该注解</td></tr></tbody></table><table><thead><tr><th>定义注解中的配置参数，包括：</th></tr></thead><tbody><tr><td>1.所有基本类型</td></tr><tr><td>2.String</td></tr><tr><td>3.枚举类型</td></tr><tr><td>4.基本类型、String以及枚举的数组</td></tr></tbody></table><blockquote><p><code>Tips</code>1.因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值</p><p>2.注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值</p><p>3.大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p><p>如果只写注解，相当于全部使用默认值</p><p>4.如果参数名称是<code>value</code>，且只有一个参数，那么可以省略参数名称</p></blockquote><h2 id="4-2-定义注解"><a href="#4-2-定义注解" class="headerlink" title="4.2 定义注解"></a>4.2 定义注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-1-元注解"><a href="#4-2-1-元注解" class="headerlink" title="4.2.1 元注解"></a>4.2.1 元注解</h3><blockquote><p>有一些注解可以修饰其他注解，这些注解就称为元注解</p></blockquote><table><thead><tr><th>元注解</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td><code>@Target</code>^常用^：定义<code>Annotation</code>能够被应用于源码的哪些位置</td><td>类或接口：<code>ElementType.TYPE</code></td><td>字段：<code>ElementType.FIELD</code></td><td>方法：<code>ElementType.METHOD</code></td><td>构造方法：<code>ElementType.CONSTRUCTOR</code></td><td>方法参数：<code>ElementType.PARAMETER</code></td></tr><tr><td><code>@Retention</code>^常用^：定义了<code>Annotation</code>的生命周期</td><td>仅编译期：<code>RetentionPolicy.SOURCE</code></td><td>仅class文件：<code>RetentionPolicy.CLASS</code></td><td>运行期：<code>RetentionPolicy.RUNTIME</code></td><td></td><td></td></tr><tr><td><code>@Repeatable</code>：定义<code>Annotation</code>是否可重复</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>@Inherited</code>：使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组&#123; ElementType.METHOD, ElementType.FIELD &#125;</span></span><br><span class="line"><span class="meta">@Target</span>(&#123;</span><br><span class="line">    ElementType.METHOD,</span><br><span class="line">    ElementType.FIELD</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Repeatable应用不是特别广泛</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Reports<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(<span class="title">ElementType</span>.<span class="title">TYPE</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Report</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Reports &#123;</span><br><span class="line">    Report[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解</span></span><br><span class="line"><span class="meta">@Report</span>(type=<span class="number">1</span>, level=<span class="string">"debug"</span>)</span><br><span class="line"><span class="meta">@Report</span>(type=<span class="number">2</span>, level=<span class="string">"warning"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果一个类用到了@Report</span></span><br><span class="line"><span class="meta">@Report</span>(type=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//它的子类默认也定义了该注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-定义Annotation"><a href="#4-2-2-定义Annotation" class="headerlink" title="4.2.2 定义Annotation"></a>4.2.2 定义<code>Annotation</code></h3><table><thead><tr><th>定义<code>Annotation</code>的步骤</th><th>代码举例</th></tr></thead><tbody><tr><td>1.用<code>@interface</code>定义注解</td><td>public @interface Report { }</td></tr><tr><td>2.添加参数、默认值</td><td>public @interface Report {     int type() default 0;     String level() default “info”;     String value() default “”; }</td></tr><tr><td>3.用元注解配置注解</td><td>@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Report {     int type() default 0;     String level() default “info”;     String value() default “”; }</td></tr></tbody></table><blockquote><p><code>Tips</code>：1.把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值</p><p>2.其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code></p></blockquote><h2 id="4-3-处理注解"><a href="#4-3-处理注解" class="headerlink" title="4.3 处理注解"></a>4.3 处理注解</h2><h1 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5.泛型"></a>5.泛型</h1><h1 id="6-集合"><a href="#6-集合" class="headerlink" title="6.集合"></a>6.集合</h1><h1 id="14-计算机网络"><a href="#14-计算机网络" class="headerlink" title="14.计算机网络"></a>14.计算机网络</h1><h2 id="14-1-基础"><a href="#14-1-基础" class="headerlink" title="14.1 基础"></a>14.1 基础</h2><h3 id="14-1-1-IP"><a href="#14-1-1-IP" class="headerlink" title="14.1.1 IP"></a>14.1.1 IP</h3><blockquote><p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<code>127.0.0.1</code>，还有一个IP地址，例如<code>101.202.99.12</code>，可以通过这个IP地址接入网络。</p><p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p><p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP &#x3D; 101.202.99.2</span><br><span class="line">Mask &#x3D; 255.255.255.0</span><br><span class="line">Network &#x3D; IP &amp; Mask &#x3D; 101.202.99.0</span><br></pre></td></tr></table></figure><h3 id="14-1-2-网络模型"><a href="#14-1-2-网络模型" class="headerlink" title="14.1.2 网络模型"></a>14.1.2 网络模型</h3><table><thead><tr><th>OSI</th><th>TCP/IP</th></tr></thead><tbody><tr><td>应用层：提供应用程序之间的通信</td><td>应用层</td></tr><tr><td>表示层：处理数据格式，加解密等等</td><td>应用层</td></tr><tr><td>会话层：负责建立和维护会话</td><td>应用层</td></tr><tr><td>传输层：负责提供端到端的可靠传输</td><td>传输层</td></tr><tr><td>网络层：负责根据目标地址选择路由来传输数据</td><td>IP层</td></tr><tr><td>链路层：负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等</td><td>网络接口层</td></tr><tr><td>物理层：同链路层</td><td>网络接口层</td></tr></tbody></table><h3 id="14-1-3-IP-amp-TCP-amp-UDP"><a href="#14-1-3-IP-amp-TCP-amp-UDP" class="headerlink" title="14.1.3 IP&amp;TCP&amp;UDP"></a>14.1.3 IP&amp;TCP&amp;UDP</h3><table><thead><tr><th>常用协议</th></tr></thead><tbody><tr><td><code>IP协议</code>是一个分组交换，它不保证可靠传输，IP协议只负责发数据包，不保证顺序和正确性</td></tr><tr><td><code>TCP协议</code>是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的。TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据；TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等</td></tr><tr><td><code>UDP协议</code>（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020/06/06/mysql-manual</title>
      <link href="2020/06/06/mysql-manual/"/>
      <url>2020/06/06/mysql-manual/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020/06/06/aboutBlog</title>
      <link href="2020/06/06/aboutBlog/"/>
      <url>2020/06/06/aboutBlog/</url>
      
        <content type="html"><![CDATA[<h1 id="建站流程？"><a href="#建站流程？" class="headerlink" title="建站流程？"></a>建站流程？</h1><p>具体可参考<a href="www.hexocn.cn">Hexo官网</a></p><p>(1) 基础环境搭建(安装node、git和npm/cnpm),具体操作参考官网，不做演示</p><p>(2) 博客环境搭建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装hexo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -g 表示全局安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cnpm install -g hexo-cli</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> your_blog_name 表示博客根目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init your_blog_name</span></span><br></pre></td></tr></table></figure><h1 id="关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？"><a href="#关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？" class="headerlink" title="关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？"></a>关于hexo本地启动正常但部署时出现样式（CSS、JS等）未加载问题？</h1><p>(1) 修改hexo中 _config.yml 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span></span><br><span class="line"><span class="comment"># root 后面写你 github 仓库的名字</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/XXX.github.io</span></span><br></pre></td></tr></table></figure><p>(2) 重新上传</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g </span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
